[ { "title": "[JS] 바닐라 JS에서 정말 간단한 MVVM + Repository 패턴 사용하기", "url": "/posts/MVVM-in-vanilla-js/", "categories": "Develop, Javascript", "tags": "Javascript", "date": "2023-01-13 21:55:00 +0900", "snippet": "🛫 시작하기에 앞서간단한 바닐라 자바스크립트 프로젝트를 진행하면서 바닐라 자바스크립트에서의 MVVM + Repository 패턴을 학습한 내용을 기록하려고 합니다.🤔 왜 하필 MVVM?처음에는 안드로이드를 개발하면 많이 사용하는 AAC-MVVM(AAC-ViewModel을 활용한 MVVM) 패턴에 익숙해서 바닐라 자바스크립트 역시 MVVM으로 개발을 시작하였습니다. 하지만, AAC-MVVM과 Pure MVVM에는 차이가 있었고 Pure MVVM을 개발해본 적이 없어 AAC-ViewModel과 일반 ViewModel의 차이를 또한 공부해보고 싶어 본 프로젝트를 진행하였습니다!🤨 AAC ViewModel vs MVVM ViewModel일단 AAC의 ViewModel과 MVVM의 ViewModel은 이름만 같을 뿐 완전히 다른 ViewModel입니다. 하지만, AAC ViewModel을 활용해서 MVVM을 구현할 수도 있기 때문에 AAC ViewModel을 쓰면 MVVM이 아니라고 할 수도 없습니다!AAC ViewModel ViewModel의 대안은 UI에 표시되는 데이터를 보유하는 일반 클래스입니다. 이는 활동이나 탐색 대상 간에 이동할 때 문제가 될 수 있습니다. 이렇게 하면 인스턴스 상태 저장 메커니즘을 사용하여 데이터를 저장하지 않을 경우 해당 데이터가 소멸됩니다. ViewModel은 데이터 지속성을 위한 편리한 API를 제공하여 이 문제를 해결합니다. ViewModel 클래스의 주요 이점은 기본적으로 두 가지입니다. UI 상태를 유지할 수 있습니다. 비즈니스 로직에 대한 액세스 권한을 제공합니다. ViewModel 개요Google 공식 문서를 확인해보면 알 수 있듯이, MVVM 패턴에 대한 설명 없이 AAC(Android Architecture Component)의 ViewModel 만을 알려주는 것을 알 수 있습니다.AAC ViewModel은 Android의 수명 주기를 고려할 때 UI와 관련된 데이터들을 저장하고 관리하는 것을 목적으로 설계되었습니다. 즉, 데이터를 관리하고 바인딩하고 정제하기 위해 사용하는 ViewModel이 아닌 화면이 회전했을 때와 같이 상태가 변화 했을 때도 데이터 라이프 사이클을 관리하고 유지하는 데에 사용됩니다.MVVM ViewModelMVVM ViewModel은 View와 Model 사이에서 데이터를 관리, 정제 및 바인딩을 하기 위한 클래스로, 값이 변경이 됐을 때 그 상태 변화를 View에게 전달하는 작업을 합니다.MVVM에서 View와 ViewModel의 관계는 연결 상태를 최소화하고 ViewModel은 데이터가 변한 것을 View에 전달하고 View에서는 화면 정보의 변화를 ViewModel에 전달해야 합니다.🫠 MVVM + Repository 개발하기🗂️ 폴더 구조.├── app.js├── js│   ├── abstract│   │   ├── binder.js│   │   ├── model.js│   │   └── view.js│   ├── binder│   │   └── sub-binder.js│   ├── config│   │   └── *│   ├── constant│   │   └── *│   ├── error│   │   └── *│   ├── model│   │   └── sub-model.js│   ├── repository│   │   └── repository.js│   ├── ui│   │   └── *│   ├── util│   │   └── type-check.js│   ├── view│   │   └── sub-view.js│   └── viewmodel│   └── sub-view-model.js├── scss│   └── styles.scss└── views └── index.html abstract: binder, model, view로 사용하기 위한 추상 클래스를 모아둔 폴더 binder: AddEventListener 등 이벤트 바인딩을 위한 클래스를 모아둔 폴더 config: Fetch 등을 통해 네트워크에 요청을 할 때 사용할 config 들을 모아둔 폴더 constant: 상수들을 모아둔 폴더 error: Error를 상속받은 클래스를 모아둔 폴더 model: 모델 클래스를 모아둔 폴더 repository: 데이터 통신을 통해 가져온 데이터들을 저장하는 클래스를 모아둔 폴더 ui: UI 변경 (ProgressBar, Alert 등)을 사용하는 클래스를 모아둔 폴더 util: 유틸리티 클래스를 모아둔 폴더 view: 뷰 클래스를 모아둔 폴더 viewmodel: 뷰모델 클래스를 모아둔 폴더🐛 MVVM + Repository 로직대부분의 프로세스는 다음과 같습니다. Binder를 통해서 이벤트가 들어온 것을 확인합니다. 들어온 이벤트를 기반으로 적절한 ViewModel의 메소드를 실행시킵니다. 네트워크 요청이 필요한 이벤트일 경우, ViewModel에서는 Repository에서 데이터를 가져오도록 합니다. Repository에서는 Model에 맞게 데이터를 불러온 뒤에 값을 ViewModel에 전달합니다. ViewModel에서는 Repository에서 받은 데이터를 적절히 가공하여 저장합니다. View에서는 ViewModel의 가공된 데이터를 기준으로 화면에 출력합니다.🛠️ 코드간단한 자바스크립트 코드를 보면서 로직을 파악해보도록 하겠습니다.Binder// binder.jsexport default class Binder { constructor() { if (this.constructor === Binder) { throw new Error(&#39;Abstract Error&#39;); } } bindEvents() { throw new Error(&#39;Abstract Error&#39;); }}Binder는 BindEvents() 추상 메서드를 가지고 있는 추상 클래스입니다. Binder를 상속받은 클래스를 사용해서 유저는 이벤트를 바인딩 할 수 있습니다.// sub-binder.jsclass SubBinder extends Binder { bindEvents() { const tempEl = document.querySelector(&#39;.my-temp-button&#39;); const subViewModel = new SubViewModel(); const subView = new SubView(subViewModel); tempEl.addEventListener(&#39;click&#39;, async () =&amp;gt; { await subViewModel.action(); subView.render(); }); }}export default new SubBinder();간단한 예를 살펴보면 이벤트가 일어났을 때 ViewModel을 통해 데이터를 가공하고 View를 통해 렌더링을 하게 하였습니다.View// view.jsexport default class View { constructor() { if (this.constructor === View) { throw new Error(&#39;Abstract Error&#39;); } } render() { throw new Error(&#39;Abstract Error&#39;); }}View도 Binder와 동일하게 추상클래스로 만들어주었습니다. 자식 클래스들은 View를 상속받고 ViewModel의 데이터 가공이 끝났을 때 render()를 호출하여 화면을 업데이트 해줍니다.// sub-view.jsexport default class SubView extends View { #subViewModel; constructor(subViewModel) { super(); this.#subViewModel = subViewModel; } render() { const { name, age } = this.#subViewModel.getUser(); const nameEl = document.querySelector(&#39;.my-name&#39;); const ageEl = document.querySelector(&#39;.my-age&#39;); nameEl.textContent = name; ageEl.textContent = ageEl; }}말 그대로 View에서는 ViewModel에서 가공된 데이터를 렌더링할 수 있습니다. render()는 Binder에서 모든 일이 끝난 뒤에 마지막에서 호출되기 때문에 업데이트된 데이터를 가지고 있어 새로운 데이터를 뿌릴 수 있습니다.ViewModel// sub-view-model.jsexport default class SubViewModel { #subModel; #repository = new Repository(); getUser() { return this.#subModel.getData(); } async action() { this.#subModel = await this.#repository.fetchData(); }}ViewModel은 그 범위가 달라 추상클래스 없이 개발을 진행하였습니다. 여기서는 알맞게 Model을 기준으로 데이터를 가공하거나 불러오는 작업을 합니다.Repository// repository.jsexport default class Repository { async fetchData() { const res = await fetch(&#39;https://dummyjson.com/user/1&#39;); if (!res.ok) throw new Error(&#39;Fetch Error&#39;); return new SubModel(res.json()); }}Repository에서는 데이터를 가져오는 작업을 합니다. 여기서 리턴하는 데이터는 특정 Model을 기반으로 합니다.Model// model.jsexport default class Model { constructor() { if (this.constructor === Model) { throw new Error(&#39;Abstract Error&#39;); } } setData() { throw new Error(&#39;Abstract Error&#39;); } getData() { throw new Error(&#39;Abstract Error&#39;); }}Model은 위와 같은 추상클래스를 만들어서 진행하였습니다. 물론 굳이 setData(), getData()를 추상 메서드로 만들 필요도, 꼭 이런 방식으로 Model을 개발하지 않아도 되나 이번 프로젝트를 진행하면서는 위와 같이 모델을 제작하였습니다.// sub-model.jsexport default class SubModel extends Model { #data; constructor(data}) { super(); #this.data = data; } setData(data) { this.#data = { ...this.#data ...data, } } getData() { return this.#data; }}그냥 간단하게 데이터를 불러오고 저장할 수 있도록 하였습니다.이와 같이 로직을 분리하여 간단한 바닐라 자바스크립트 MVVM 패턴을 사용할 수 있습니다..!🙂 결론간단하게 MVVM을 활용해서 개발을 해봤는데요! 사실 간단한 작업은 위와 같은 Role로도 작동이 되지만 더 큰 규모의 프로젝트가 되기 위해서는 Role Design을 더욱 상세하고 정밀하게 짜야할 것 같네요!참조 객체지향 자바스크립트 2회차(MVVM 구현) , jyoon blog version2 (happyjy.netlify.app) MVVM System 만들기 , 개발자 황준일 (junilhwang.github.io) ViewModel 개요 ,  Android 개발자 ,  Android Developers" }, { "title": "[일상] 2023 카카오 블라인드 공채 후기", "url": "/posts/road-to-kakao/", "categories": "Diary", "tags": "Diary", "date": "2022-11-25 00:09:00 +0900", "snippet": "🛫 시작하기에 앞서2023 Kakao Tech Blind Recruitment를 통해서 2023년 카카오 공채에 최종 합격을 하면서 있었던 일을 서술하는 일기장입니다.🫠 3달 동안 진행된 카카오 공채👀 카카오 블라인드 공개채용 신청사실 카카오라는 기업의 장벽이 너무 커 보였기 때문에 처음에 카카오 블라인드 공채를 신청을 할 때는 취업이 목표가 아닌 카카오 코딩테스트 문제를 풀어보는 것을 목적으로 신청했습니다. 또한, 카카오 코딩테스트는 5시간 동안 집중해서 문제를 해결해야 하는 것 때문에 작년 공채를 본 주변 친구들이 많이 어려워했었는데 얼마나 어떻게 어려운지 궁금해서 신청한 것도 한몫했었습니다..!🙂 1차 코딩테스트 합격정말 운이 좋게도 7문제 중 3문제를 해결해서 1차 코딩테스트를 합격했습니다! 이번 공채는 작년과 다르게 각 문제마다 배점이 달랐습니다. 저는 이 사실을 코딩테스트가 끝난 뒤에 인터넷에 올라온 블로그 포스트를 보고 알게 되었는데요, 각 문제에 대한 점수는 다음과 같았습니다! 문제 번호 배점 1번 30 2번 100 3번 100 4번 150 5번 300 6번 300 7번 350 저는 1번, 3번, 6번을 해결해서 총 430점으로 통과를 했습니다. 친구 중에 1번, 2번, 3번을 해결한 친구가 아쉽게도 떨어졌었는데 확실히 이번 코딩테스트에서는 단순히 문제를 푼 개수가 아니라 총 배점이 더욱 중요했던 것 같습니다.😄 2차 코딩테스트 합격2차 문제는 1차랑 다르게 REST API를 활용해서 문제를 해결하는 것과 CS 문제를 푸는 것으로 진행이 됐습니다. 사실 2차 코딩테스트를 치르기 며칠 전에 도서관에 가서 작년이랑 재작년 2차 코딩테스트 문제를 풀면서 어떤 식으로 코딩테스트가 진행되는지 확인을 했던 것이 큰 도움이 되었습니다. 카카오 2차 코딩테스트 문제 및 문제해설 2022 카카오 신입 공채 2차 온라인 코딩 테스트 for Tech developers 문제해설 – tech.kakao.com 2021 카카오 신입공채 2차 온라인 코딩 테스트 for Tech developers 문제해설 – tech.kakao.comCS는 학교에서 전공 수업을 들으면서 받은 PPT를 보면서 공부했습니다. 딱히 학교 시험처럼 CS를 암기한다는 것보다는 1회독 하는 느낌으로 읽었는데 다행히 공부했던 것 중에 몇 문제가 나와서 문제를 풀 수 있었습니다.코딩테스트는 문제를 해결하면서 실시간으로 리더보드를 확인하면서 자신의 등수를 확인할 수 있어서 더욱 집중을 하면서 문제를 풀 수 있었던 것 같습니다.리더보드는 100등까지만 보이기 때문에 저는 100등 안을 목표로 하면서 문제를 풀었습니다. 코딩테스트 중반까지는 20등 내에 들어서 “와 나 좀 하나..?” 이런 생각을 하면서 풀다가 나중에는 순위권 밖으로 벗어나서.. 계속 조금씩 총점을 높이면서 95등 내외에서 계속 놀다가 결국 코딩테스트가 끝났을 때는 딱 순위권 밖으로 벗어났습니다..그래서 정말 아쉬움이 많았었는데 다행히도 2차 코딩테스트도 합격할 수 있었습니다..!😳 1차 면접 합격모든 코딩테스트를 통과하고 나니 카카오에 정말 입사하고 싶다는 마음이 커지게 되었습니다.1차 면접은 어떻게 합격했지..?라는 생각이 많이 남았던 면접이었습니다. 면접 분위기가 나쁜 것은 아니었지만 개인적으로 제 자신에 대해서 좀 부족함을 많이 알게 된 면접이었습니다. 면접은 다른 블로그에서 언급한 것처럼 2차 코딩테스트 풀이 방식 + CS + 포트폴리오 기반 질문으로 진행됐습니다.코딩테스트 풀이 방식코딩테스트 풀이 방식은 말 그대로 2차 코딩테스트 문제를 어떻게 풀었는지에 대해서 설명했습니다.. 단순히 문제를 해결했던 것뿐만이 아니라 문제를 어떤 방식으로 접근했었는지도 설명을 했었습니다.CS 질문면접을 준비하면서 CS를 네트워크, OS, 데이터베이스 위주로 공부를 했었는데 정작 면접을 보니 거의 다 알고리즘 관련 질문으로 받았습니다. 질문에 대해 답을 하면서 아무리 생각해도 최선의 선택이 아닌 답을 한 것 같아서 대답을 하면서도 찝찝하고 좀 슬픈 느낌을 많이 받았었습니다. 그래서 개인적으로 대답하지 못한 문제들은 기억하고 있다가 면접이 끝난 뒤에 인터넷을 찾아보면서 이해했던 기억이 있네요..!포트폴리오 질문저는 개인적으로 면접관 분들에게 제가 진행한 프로젝트에 대해서 설명을 해드리고 싶었습니다. 면접을 볼 때 외에도 들뜨게 되면 TMI를 하는 경향이 있는데 면접관 분들이 제 프로젝트에 궁금증을 가지고 질문을 하셔서 들뜬 마음으로 프로젝트에 대해서 설명하였습니다.사실 CS 질문을 받을 때는 착잡했었는데 포트폴리오 질문을 받을 때는 신나서 설명을 했던 것이 기억에 남습니다!🥳 최종 면접 합격뜬금없지만 저는 면접날에 해외에 있었습니다.. ㅎㅎ 그렇기 때문에 면접 당일만큼은 와이파이 속도가 빠른 호텔을 예약하려고 했고 아고다에서 인터넷 속도가 빠르다고 한 호텔을 예약했었습니다. 근데 정작 면접 전날 해당 호텔에 도착하자마자 와이파이 속도를 측정했더니 1Mbps도 안 나와서 영상통화는 물론 인터넷 창도 안 들어가지는 대참사가 일어났습니다.이런 문제로 최종 면접을 포기하고 싶지 않아서 주변 호텔을 뛰어다니면서 와이파이 속도를 체크한 뒤에 비교적으로 빠른 곳을 예약하고 다음 날 면접을 진행했었습니다. 이전 숙소는 와이파이 속도로 거짓말을 쳤으니 환불해달라고 했지만 결국 환불은 못 받았어요.. 🥲최종 면접에서는 면접관 분들에게 제가 코딩을 좋아하는 이유, 프로그래밍을 시작하게 된 계기 등을 솔직하게 말씀을 드렸습니다. 면접관 분들도 친절하게 면접을 진행해 주셔서 카카오라는 회사에 면접을 본다는 느낌보다는 선배 개발자분들에게 저의 많이 부족한 인생사를 설명해 드리는 느낌이었습니다.면접을 치른 뒤에도 쭉 여행을 다니고 있었고 11월 24일에 다른 지역으로 넘어가느라 캐리어를 끌고 강을 지나가고 있는 사이에 면접 결과가 나왔습니다. 기대 반 걱정 반으로 가던 길을 멈추고 확인을 해보니 최종 합격이 떠있어서 좋은 마음으로 숙소까지 뛰어갈 수 있었습니다..!😆 결론사실 취업을 한다는 것은 끝이 아니라 시작을 하는 것에 가깝다고 생각합니다. 앞으로는 멋있는 카카오 개발자로 인정받기 위해서 노력하고자 합니다!" }, { "title": "[Python, Docker] smtplib 이용 시 Cannot Assign Requested Address 문제 해결하기", "url": "/posts/cannot-assign-requested-address/", "categories": "Develop, Python", "tags": "Python, Docker", "date": "2022-11-21 17:33:00 +0900", "snippet": "🛫 시작하기에 앞서OSError: [Errno 99] Cannot assign requested address저는 도커에서 특정 요청이 들어오면 파이썬 라이브러리인 smtplib을 활용해서 지메일을 통해 메일을 보내는 기능을 구현하는 도중 해당 문제를 마주하였습니다.사실 개발환경에서는 잘 동작했으나 서버에서 컨테이너로 동작시키면 해당 문제가 발생해서 처음에는 도커 자체만의 문제인 줄 알았습니다. 하지만, 도커 뿐만이 아니라 다른 문제도 해결해야 해당 문제를 해결할 수 있습니다..!🤔 그래서 해당 에러가 뭔데? OSError: [Errno 99] Cannot assign requested address this means the provide ip/port is already taken. Change your ip/port and try again.해당 ip:port가 이미 사용되고 있거나 다른 이유로 해당 ip:port를 사용할 수 없어서 생기는 에러입니다.🫠 해결 과정🐳 Docker-Compose에서 포트 열어주기당연하겠지만 Docker-Compose에서 포트를 열어줘야 합니다. SMTP의 경우 25번포트를 사용하고 Gmail의 경우에는 587번포트를 사용하여 메일을 주고 받고 있습니다.저의 경우에는 Gmail을 통해서 메일을 보내고 있으므로 프로젝트의 587번 포트와 도커 외부의 587번 포트를 연결시켜주도록 하겠습니다.version: &#39;3.7&#39;services: my-service: # ports ports: - 587:587🐛 서버 방화벽에서 해당 포트 예외처리하기AWS, 개인 서버, 다른 서버 업체 등을 통해서 파이썬 프로그램을 실행했을 때 메일을 보내는 포트가 방화벽에 의해서 막혀있을 경우에도 해당 문제가 발생할 수 있습니다.저 또한, iwinv서버를 임대하면서 587번 포트를 열어주지 않았다는 것을 알게 된 후에 빠르게 Out-Bound 규칙에 587포트를 추가하였습니다.도커에서 포트를 연결하고 서버 방화벽에서 Out Bound 규칙에 587포트를 허가하게 만들면 해당 문제를 해결할 수 있습니다..!🙂 결론오늘은 OSError: [Errno 99] Cannot assign requested address 문제를 해결하는 방법을 알아보았습니다. 단순히 도커 문제라고 생각하고 계속 고민했다가 서버측 문제라는 것을 깨닫게 될 때까지 많은 고민을 했던 것 같습니다. 딱 저에게 맞는 문제를 겪은 분이 인터넷을 찾아봐도 잘 없어서 혹시라도 이 글을 보는 분들은 쉽게 해결할 수 있었으면 좋겠습니다!참조python - How to fix error when sending mail with django in docker container? (Cannot assign requested address) - Stack Overflow" }, { "title": "[Linux] 리눅스에서 스왑메모리를 생성해주기", "url": "/posts/make-linux-swap-memory/", "categories": "Develop, Linux", "tags": "Linux", "date": "2022-10-21 01:00:00 +0900", "snippet": "🛫 시작하기에 앞서AWS EC2 프리티어 기간이 끝난지만 최근에 프로젝트를 진행하면서 서버를 이용할 일이 생겨서 저렴한 국내 서버 호스팅 업체에서 1vCore/1GB 리눅스 서버를 활용하여 프로젝트를 배포하였습니다.만족하면서 사용하고 있었으나 도커와 젠킨스, 장고 서버까지 틀어져 있다보니 메모리가 아슬아슬한 상황이 되었고 2GB로 서버를 증축하기에는 비용이 2배가 들어 약간 꺼려지는 상황이었습니다. 1GB 중에는 60MB 정도는 항상 free 상태였고 가끔 튀었을 때 젠킨스에서 메모리 부족 문제가 발생하는 부분만 해결하고 싶었기 때문에 Swap 메모리를 활용하여 이를 해결하기로 했습니다!SWAP 메모리란?Swap 메모리란 실제 메모리가 가득 찼지만 더 많은 메모리 용량이 필요할 때 디스크 공간을 치환하여 부족한 메모리를 대체하는 것을 의미합니다. 실제로 존재하는 메모리가 아니라 디스크 공간을 메모리처럼 활용하는 것이기 때문에 가상 메모리이기도 합니다.아무래도 RAM보다 HDD나 SSD의 속도가 훨씬 느리기도 하고 HDD나 SSD에 접근하는 시간도 문제이기 때문에 일반적인 메모리보다는 속도가 매우 느려 Swap 메모리를 사용하게 된다면 전반적인 속도가 느려질 수 밖에 없습니다.하지만, 메모리가 부족해서 ssh 연결도 안되고 툭 꺼져버리는 상황을 방지하기 위해서 미리 임시방편으로 Swap 메모리를 만들어 놓는게 좋을 것 같습니다! 🥲🫠 리눅스에서 Swap 메모리 확인Swap 메모리를 확인하기 위해서는 swapon -s나 free -h, 또는 top 명령어를 활용할 수 있습니다.저는 미리 4GB만큼 스왑메모리를 생성했기 때문에 정상적으로 뜨는 것을 확인할 수 있습니다.🐛 리눅스에서 Swap 메모리 만들기 처음으로는 Swap 메모리를 Swap 파일인 swapfile로 잡습니다. $ sudo dd if=/dev/zero of=/swapfile bs=128M count=32 bs는 포맷의 단의로 128M는 128MB를 의미합니다. M을 생략하여 바이트 단위로 생성도 가능하므로 bs=1024와 같이 1KB로 집을 수도 있습니다. count는 블록의 개수를 의미합니다. 즉, 128M의 블록을 32개 생성한 것이므로 4GB 만큼의 Swap 파일을 포맷했다고 할 수 있겠네요. 다음은 Swap 파일에 퍼미션을 부여합니다. $ sudo chmod 600 /swapfile Swap 파일에 rw- 퍼미션을 부여하여 읽기와 쓰기가 가능하도록 하였습니다. Swap 영역을 할당해줍니다. $ sudo mkswap /swapfile Swap 영역에 Swap 파일을 추가하여 스왑 파일을 즉시 사용할 수 있도록 합니다. $ sudo swapon /swapfile 여기까지 제대로 진행됐는지 확인하기 위해서 swapon 명령어를 통해 확인합니다. $ sudo swapon -s 제대로 진행이 됐을 경우 /swapfile이 표시되는 것을 확인할 수 있습니다. /etc/fstab에 명령어 추가합시다. vim이나 편하신 에디터를 통해서 /etc/fstab를 수정할 겁니다. 저는 vim을 통해서 수정할 것이기 때문에 다음과 같이 파일을 열었습니다. $ sudo vim /etc/fstab 이후 파일 맨 아래에 다음 명령어를 추가하였습니다. (... 상위 텍스트 ...)/swapfile swap swap defaults 0 0 해당 명령어를 통해서 시스템이 재시작되더라도 자동으로 활성화하게 할 수 있습니다. 마지막으로 Free 명령어를 통해서 Swap 메모리가 잘 생성이 됐는지 확인하겠습니다. $ free 🐋 Swap 메모리 비활성화/삭제Swap 메모리 비활성화스왑메모리를 더이상 사용하고 싶지 않을 경우에는 다음 명령어를 통해서 Swap 메모리를 비활성화 할 수 있습니다.# 단일 Swap 메모리 비활성$ sudo swapon /swapfile# 모든 Swap 메모리 비활성화$ swapon -aSwap 메모리 삭제폴더를 삭제하듯이 /swapfile을 삭제하면 됩니다.$ sudo rm -r /swapfile🙂 결론오늘은 Swap 메모리를 만드는 방법에 대해서 알아보았습니다.앞으로는 메모리 용량이 작은 서버를 이용할 때 메모리가 부족해서 사용하기 불편한 것을 예방하기 위해 미리 Swap 메모리를 미리 만들어야겠네요!참조 리눅스 : Swap 메모리란? 리눅스 공유 메모리 - Voyager of Linux 젠킨스 JVM 메모리 설정" }, { "title": "[일상] 숭실대학교 SFSU 교환학생 예비 합격", "url": "/posts/SFSU-exchange-program/", "categories": "Diary", "tags": "Diary", "date": "2022-09-01 16:02:00 +0900", "snippet": "🛫 시작하기에 앞서IT에 관심이 많지 않은 사람이라도 FAANG(Facebook 현 Meta, Amazon, Apple, Netflix, Google)처럼 세계적인 빅테크 기업과 Airbnb같은 유니콘 기업들을 들어보고 사용하시고 계실 겁니다.이러한 기업들은 대부분 캘리포니아 샌프란시스코나 실리콘밸리에 위치하기 때문에 어려서부터 미국에 가서 영감을 받고 싶다는 생각을 가지고는 했습니다.이제 졸업까지 얼마 남지도 않았고 학생 때 할 수 있는 챌린지 중 하나인 교환학생을 가고 싶어 이번년도에 휴학하면서 교환학생을 준비했습니다!🫠 준비 과정📝 가고 싶은 대학 선정저희 학교에서 갈 수 있는 대학교가 100곳이 넘는 만큼 가고 싶은 대학교가 많아서 선택을 하는데 많은 시간이 소요됐습니다. SAF를 통해서 갈 수 있는 학교들도 있지만, 학비가 엄청 비싼 탓에 SAF를 통해서 갈 엄두가 안 나더라고요.. ㅎㅎ사실 교환학생을 가고 싶었던 이유는 낯선 환경에 놓여져 제 자신을 발전시키고 싶었던 것과 한 번도 안 가봤던 미국이라는 나라에 가보는 것, 나중에 미국에서 취업하기 위해서 Job Offer를 받을 수 있도록 미리 준비해두는 것 같은 이유가 있었습니다.그래서 대학의 간판보다는 위치 상으로 가장 가고 싶었던 캘리포니아 쪽 대학을 선택하여 준비하였습니다.📚 TOEFL 준비아무래도 토플 성적이 높으면 더 좋은 대학을 갈 수 있으므로 다다익선이었지만 제가 기준으로 잡은 안전빵 점수 이상으로만 맞추자는 마인드로 공부를 했었습니다.시험 결과는 딱 안전빵에 턱걸이로 맞췄는데 Reading 파트에 실수한 것이 많아 너무 아쉬워서 좀 더 준비할까 생각도 했었습니다. 하지만, 시험을 한 번 치루는데 20만원이 넘는 금액을 지불해야 하는 것이 너무 충격이기도 하고 그렇게 성적을 올린다고 해도 UC Riverside를 가게 될텐데 해외 대학 알못이기도 하고 어차피 교환학생으로 1학기만 파견 갔다 오는 것인데 이렇게까지 해야하나라는 생각이 들어 현재 성적에 만족하고 마무리를 지었습니다.🐛 자기소개서 작성학교에서 자유 양식으로 자기소개서를 작성하라고 해서 소신껏 작성하였습니다. 자기소개서는 국문 1페이지, 영문 1페이지로 작성하였으며 거짓말 없이 가고 싶었던 이유를 작성해도 좋을 것 같습니다.🗣 면접면접은 3대 7로 진행했고 영문으로 답변하라는 질문이 있다고 에브리타임에서 봤었으나 다행히 전부 한국어로 진행하였습니다.면접은 7명 합쳐서 20분 정도로 매우 짧게 진행되었고 가고 싶은 이유, 포부, 어떤 식으로 공부할 것인지 등 간단한 질문을 받았습니다.🙂 결론그 결과 제가 지원했던 SFSU에 예비 합격을 했고 상대교에도 제출할 서류가 남아있어 아직 할 일이 많이 남아 있습니다. 합격하기 전까지는 생각하지 않았는데 2022년 9월 기준 달러화도 엄청 높아지고 있고 물가상승률도 가파르게 높아지고 있어서 아무래도 처음 생각했던 것 보다 돈이 많이 깨질 것 같아서 걱정이네요.. ㅠㅠ아 추가적으로, 저희 학교에서도 최대한 학생들을 보내려고 해주시는지 넣으면 웬만하면 붙는다고 하니까 만약에 숭실대학교 학생이시면 교환학생 한 번 넣어보는 것도 좋을 것 같아요!" }, { "title": "[일상] 한 달 간의 2022 토스 NEXT 챌린지 여정", "url": "/posts/road-to-toss/", "categories": "Diary", "tags": "Diary", "date": "2022-08-26 02:36:00 +0900", "snippet": "🛫 시작하기에 앞서2022년 토스 신입 공채인 2022 토스 NEXT 챌린지를 지원하면서 기억에 남는 점과 아쉬웠던 부분을 서술하는 일기장 입니다.🫠 한 달 동안 진행한 챌린지👀 코딩 테스트 신청아직 대학교를 졸업한 상태도 아니었지만 알고리즘 공부도 하고 싶었고 평소에도 핀테크 기업과 토스에 관심이 많아서 이번 토스 NEXT 챌린지에 지원하였습니다.신청한 직군은 Core Banking으로 평소에 안드로이드, 플러터 앱과 프론트엔드 개발을 주로 했던 저에겐 금융과 관련된 개발이나 코어 개발에 관련된 포트폴리오가 거의 없어서 남들에 비해서 뒤쳐질 수 밖에 없었던 선택이었습니다.하지만 플랫폼의 핵심 기술을 개발하는 것에 관심이 있고 단순히 서버와 통신해서 앱을 개발하고, 프론트엔드 웹 페이지를 개발하는 것 보다 서비스 자체를 개발하고 싶어서 꼭 Core Banking 직군으로 넣어야 겠다고 다짐했습니다.🚀 코딩 테스트 + 서술형 (합격)1차는 코딩 테스트과 서술형으로 진행하였습니다.코딩 테스트는 제 기준으로 많이 풀만한 난이도였고 서술형 또한 프론트앤드나 앱 개발과는 하나도 상관이 없는 문제들이었으나 제가 개발하면서 마주하던 일들이 존재하여 소신껏 작성하였습니다.그 결과 운이 좋게 코딩 테스트를 합격했습니다. :)🥲 직무 인터뷰 (불합격)2차는 비대면으로 직무 인터뷰를 진행했고 제가 제출한 포트폴리오와 CS 관련 질문을 받았습니다.면접 분위기는 정말 편안한 상태로 진행하였고 제가 긴장을 많이 하는 타입인데도 불구하고 면접을 시작할 때 아이스 브레이킹까지 해주셔서 면접을 보는 것 보다는 현업 개발자 분들과 개발 관련 프리토킹을 하는 느낌이었습니다.면접은 한 시간 정도 진행했으며 마지막에 역 인터뷰를 통해서 평소에도 토스에 궁금하던 내용까지 질문하여 궁금증을 풀 수 있었습니다.사실 면접 때 말을 못 하거나 그런 부분은 없는 것 같아 뭔가 붙을 것 같다는 자신감을 조금 가지고 있었는데 인터뷰에서 불합격 하니 아쉬움이 많았습니다.아무래도 면접을 곱씹어 봤을 때 제 포트폴리오가 프론트엔드와 앱 개발로 이루어져 있던 점, 그리고 그로 인해서 면접관 님들이 할 수 있는 질문들이 한정적이었다는 것이 불합격 요인이라고 생각이 되었습니다.😌 느낀 점합격여부를 떠나서 개발자 분들과 이렇게 깊게 생각하고, 프로젝트에 대해서 논의할 수 있던 시간은 제가 엄청 값지고 재미있는 시간이었습니다.특히, 면접관 분들을 보면서 이런 분들 밑에서 개발을 해보면 얼마나 좋을까 이런 생각도 들어서 취업에 대한 열정이 더 커지는 계기가 되었습니다.앞으로도 이런 값지고 좋은 경험을 하고 싶네요!" }, { "title": "[React, JS] 완전 이쁜 WYSIWYG의 희망편, 밀크다운", "url": "/posts/milkdown-the-best-wysiwyg/", "categories": "Develop, React", "tags": "React, Javascript, WYSIWYG, 마크다운", "date": "2022-07-02 22:01:00 +0900", "snippet": "🛫 시작하기에 앞서🙃 밀크다운이라고 들어봤어?밀크다운(Milkdown)은 Typora에 영감을 받아서 제작된 WYSIWYG(What You See Is What You Get) 마크다운(Markdown) 에디터입니다. Prosemirror와 Remark를 기반으로 제작되었습니다.기본 디자인이 Material 디자인과 Nord 테마로 적용돼 있어서 정말정말정말로 예쁩니다. 😁온라인 데모에서 직접 확인할 수 있으니 한 번 체험해 보셔도 좋을 것 같네요!저는 리액트에서 사용했기에 리액트를 기준으로 설명해 드릴 예정입니다. 밀크다운 도큐먼트에 React를 포함한 Vue, Svelte, SolidJS, Next.js, angular, Vue2, VanillaJS에서 사용하는 방법이 나와 있으니 다른 방식으로 개발하시는 분들은 위 도큐먼트를 확인해주시면 될 것 같습니다!🚀 밀크다운 시작하기➕ 밀크다운 설치하기리액트에서 밀크다운을 사용하기 위해서는 기본적으로 @milkdown/react, @milkdown/core, @milkdown/prose, @milkdown/preset-commonmark, @milkdown/theme-nord를 설치하셔야 합니다.npm install @milkdown/react @milkdown/core @milkdown/prosenpm install @milkdown/preset-commonmark @milkdown/theme-nord그 이후에 기본적인 밀크다운 컴포넌트를 생성하는 것은 매우 간단합니다!import React from &#39;react&#39;;import { Editor, rootCtx } from &#39;@milkdown/core&#39;;import { nord } from &#39;@milkdown/theme-nord&#39;;import { ReactEditor, useEditor } from &#39;@milkdown/react&#39;;import { commonmark } from &#39;@milkdown/preset-commonmark&#39;;export const MilkdownEditor: React.FC = () =&amp;gt; { const editor = useEditor((root) =&amp;gt; Editor.make() .config((ctx) =&amp;gt; { ctx.set(rootCtx, root); }) .use(nord) .use(commonmark), ); return &amp;lt;ReactEditor editor={editor} /&amp;gt;;};직접적인 컴포넌트는 ReactEditor를 통해서 생성을 하며 editor props을 통해서 밀크다운 설정값을 넣어주면 됩니다.🐛 밀크다운에 초기 값 넣기밀크다운 에디터에서 처음에 초기 값(텍스트)을 넣어서 서식을 제공하거나, 읽기 모드로 변경하여 사용자에게 보여주고 싶을 경우에는 아래와 같은 방식으로 초기 값을 넣어줄 수 있습니다.import { defaultValueCtx } from &#39;@milkdown/core&#39;;// More codes here..// 초기 텍스트const defaultValue = &quot;# Hello My Default Value!&quot;const editor = useEditor((root) =&amp;gt; Editor.make() .config((ctx) =&amp;gt; { ctx.set(rootCtx, root); }) // 아래 코드를 추가하여 초기 텍스트 삽입 .config((ctx) =&amp;gt; { ctx.set(defaultValueCtx, defaultValue); }// More codes here..🎧 밀크다운을 읽기 모드(Read-only)로 변경밀크다운에 초기 값 넣기에서 언급했듯이, 밀크다운을 단순히 편집기로 사용하는 것 이외에도 JSON이나 HTML, Markdown을 가져와서 텍스트를 읽기 전용으로만 읽게 할 수 있습니다. 읽기 모드는 아래 코드로 적용할 수 있습니다.import { editorViewOptionsCtx } from &#39;@milkdown/core&#39;;// More codes here..const editor = useEditor((root) =&amp;gt; Editor.make() .config((ctx) =&amp;gt; { ctx.set(rootCtx, root); }) // 이 부분을 삽입하여 읽기 모드로 변경 가능 .config((ctx) =&amp;gt; { ctx.set(editorViewOptionsCtx, { editable: () =&amp;gt; false }); })// More codes here..🗻 Nord 테마 라이트/다크 모드 설정단순히 nord 테마를 쓰면 다크 모드로 설정이 되는데, 수동으로 라이트나 다크 모드로 변경하고 싶으면 코드를 다음과 같이 바꾸면 됩니다.- import { nord } from &#39;@milkdown/theme-nord&#39;;+ import { nordLight, nordDark } from &#39;@milkdown/theme-nord&#39;;- .use(nord)+ .use(nordLight)# 혹은+ .use(nordDark)🫠 플러그인 삽입유의사항plugin-tooltip이나 plugin-menu와 같이 구글 아이콘을 사용하는 경우에는 미리 index.html에 구글 아이콘을 추가해야 합니다.&amp;lt;!-- index.html --&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/icon?family=Material+Icons&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/icon?family=Material+Icons+Outlined&quot; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;!-- more codes here.. --&amp;gt;&amp;lt;/html&amp;gt;plugin-tooltip툴팁 플러그인은 텍스트를 더블클릭하여 툴팁이 뜨게 할 수 있습니다.해당 플러그인은 다음을 통해서 설치할 수 있습니다.npm install @milkdown/plugin-tooltip또한 설치된 플러그인은 editor에 다음을 추가하여 삽입할 수 있습니다.import { tooltip } from &#39;@milkdown/plugin-tooltip&#39;;// 에디터 코드.use(tooltip)plugin-menu메뉴 플러그인은 상단에 메뉴를 뜨게 할 수 있습니다.해당 플러그인은 다음을 통해서 설치할 수 있습니다.npm install @milkdown/plugin-menu또한 설치된 플러그인은 editor에 다음을 추가하여 삽입할 수 있습니다.import { menu } from &#39;@milkdown/plugin-menu&#39;;// 에디터 코드.use(menu)그 이외의 수많은 플러그인그 이외에도 밀크다운에서는 수많은 플러그인을 지원하고 있으니 한 번 체크하는 것을 추천해 드립니다. 밀크다운 공식 플러그인 밀크다운 커뮤니티 플러그인 🙊 밀크다운을 vscode에서 사용하기밀크다운을 vscode에 설치해서 마크다운을 깔끔하게 수정할 수 있습니다. 설치 방법은 다음과 같습니다.이름: MilkdownID: mirone.milkdown설명: Edit markdown in a WYSIWYG way, powered by milkdown.버전: 0.0.15게시자: mironeVS Marketplace 링크: &amp;lt;https://marketplace.visualstudio.com/items?itemName=mirone.milkdown&amp;gt;해당 링크에 들어가서 밀크다운을 설치하거나 좌측 플러그인을 선택하여 마켓플레이스에 진입한 뒤, milkdown을 검색하여 설치합니다.이후 맥의 경우 command + shift + p , 윈도우의 경우 ctrl + shift + p를 눌러 명령 팔레트를 연 뒤에 Milkdown : Open with milkdown을 눌러서 밀크다운을 실행합니다.😌 결론오늘은 밀크다운을 사용하는 방법을 알아보았습니다. 강력한 플러그인들과 WYSIWYG의 장점을 한 번에 사용할 수 있어서 너무 마음에 드는 라이브러리였습니다!참조 Milkdown Saul-Mirone/milkdown: 🍼 Plugin driven WYSIWYG markdown editor framework. (github.com) " }, { "title": "[일상] 2022년 네이버 공채 코딩테스트 후기", "url": "/posts/i-tested-naver-test/", "categories": "Diary", "tags": "Diary", "date": "2022-07-02 18:06:00 +0900", "snippet": "시작하기에 앞서2022년 7월 2일에 이루어진 네이버 기술 직군 신입 채용 : Track 공채 코딩테스트를 본 후에 느낀점을 서술하려고 합니다.느낀 점코딩테스트 후기사실 처음 보는 코딩 테스트라 정신없이 풀기는 했는데 생각했던 것보다는 쉬운 편이었습니다. 프로그래머스 카카오 문제를 풀다 보면 레벨 3 이후에는 어떻게 풀어야 할지 감이 안 오던데 그래도 네이버는 모든 문제 전부 어떠한 방식으로 접근해야 할지 감이 오기는 했습니다.다만, 접근 방법만 알고 푸는 방법을 몰랐기 때문에 주어진 테스트케이스를 통과하는 문제는 4문제 중에 2문제뿐이었습니다. 2솔이라고 말하기도 뭐한 게, 히든 케이스가 있으면 분명히 그 두 문제도 몇 가지 예외로 인해서 틀릴 것 같네요..그래도 문제 자체가 재미있어서 많은 도움이 되는 시간이었습니다. 해결하지 못한 두 문제는 정확한 문제가 기억나지는 않지만 기억에 그나마 있을 때 문제를 생각해 내서 혼자서 풀어볼 생각입니다. 앞으로도 영영 제가 못 푸는 문제가 있다면 아쉽고 잠도 제대로 못 잘 것 같아서요.. ㅎㅎ다른 코딩 테스트와의 차별점앞서 말했듯이, 저는 이번 코딩 테스트가 처음인데 다른 회사와는 달리 듀얼 모니터도 못 쓰고 카메라를 계속 켜놓고 책상을 정리해야 해서 많이 힘들었어요. 듀얼 모니터를 못 쓰는 것이 힘들거나 카메라를 계속 켜놓는 것 자체가 힘든 건 아닌데 핸드폰을 거치할 곳이 딱히 없고 책상이나 방(핸드폰을 1미터 거리에 위치시키기 위해서)을 정리해둬야 하는 부분이 좀 색다른 느낌이었어요!" }, { "title": "[React] CSS 애니메이션 없이 움직이는 이미지 슬라이더 만들기", "url": "/posts/react-image-slider/", "categories": "Develop, React", "tags": "React", "date": "2022-06-03 19:09:00 +0900", "snippet": "시작하기에 앞서예전부터 즐겨보는 유튜브 채널 중에 devaslife라는 유튜버가 있습니다. VIM으로 풀스택 개발을 하는 동영상을 주로 올리는데 최근에 봤던 How I built a software agency wesite with Next.js + Tailwind CSS (in nature)에서 CSS 애니메이션 없이 자바스크립트 만으로 이미지 슬라이더를 개발하는 것을 보고 한 번 따라서 개발해보고 싶은 마음이 생겨 개발을 진행하였습니다.결과물위와 같이 body의 크기가 특정 width보다 작아지는 경우에는 이미지가 좌측으로 움직이도록 하고, 아닐 경우에는 애니메이션을 보여주지 않도록 개발을 진행하겠습니다.개발프로젝트 구조 및 사용한 라이브러리src├───hooks│ useAnimationFrame.ts│ useWindowSize.ts│└───components slide.tsx slider.tsx styled-componentuseAnimationFrame.tsimport { useCallback, useEffect, useRef } from &quot;react&quot;;const useAnimationFrame = (enabled: boolean, callback: () =&amp;gt; void) =&amp;gt; { const requestRef = useRef&amp;lt;ReturnType&amp;lt;typeof requestAnimationFrame&amp;gt;&amp;gt;(); const animate = useCallback(() =&amp;gt; { callback(); requestRef.current = requestAnimationFrame(animate); }, [callback]); useEffect(() =&amp;gt; { if (enabled) { requestRef.current = requestAnimationFrame(animate); return () =&amp;gt; { if (requestRef.current) { return cancelAnimationFrame(requestRef.current); } }; } }, [enabled, animate]);};export default useAnimationFrame;requestAnimationFrame을 사용하기 위한 훅을 개발합니다. 인자로 넘어온 enabled가 참일 때만 게속 callback() 함수를 실행하하 아닐 경우에는 아무 동작도 하지 않습니다.useWindowSize.tsimport { useEffect, useState } from &quot;react&quot;;const useWindowSize = () =&amp;gt; { const [windowSize, setWindowSize] = useState({ width: window.innerWidth, height: window.innerHeight, }); useEffect(() =&amp;gt; { const handleResize = () =&amp;gt; { setWindowSize({ width: window.innerWidth, height: window.innerHeight, }); }; window.addEventListener(&quot;resize&quot;, handleResize); return () =&amp;gt; { window.removeEventListener(&quot;resize&quot;, handleResize); }; }, []); return windowSize;};export default useWindowSize;useWindowSize 훅은 현재 화면의 width와 height를 가져올 수 있도록 합니다.slide.tsximport React from &quot;react&quot;;export type LogoSlideProps = { src: string;};const Slide = ({ src }: LogoSlideProps) =&amp;gt; { return ( &amp;lt;img alt={src} src={src} height={100} style={{ margin: &quot;0px 8px&quot; }} /&amp;gt; );};export default Slide;slide.tsx에서는 슬라이더 내부에 들어갈 이미지를 관리합니다.slider.tsximport styled from &quot;@emotion/styled&quot;;import React, { useCallback, useEffect, useRef, useState } from &quot;react&quot;;import useAnimationFrame from &quot;../hooks/use-animation-frame&quot;;import useWindowSize from &quot;../hooks/use-window-size&quot;;import Slide, { LOGO_MARGIN_WIDTH } from &quot;./logo-slide&quot;;const SliderContainer = styled.div` overflow: hidden;`;const SliderArea = styled.div` display: flex;`;const LogoArea = styled.div` display: flex;`;export type LogoSliderProps = { logos: string[];};const Slider = ({ logos }: LogoSliderProps) =&amp;gt; { const refSliderContainer = useRef&amp;lt;HTMLDivElement&amp;gt;(null); const refItemArea = useRef&amp;lt;HTMLDivElement&amp;gt;(null); const refScrollX = useRef&amp;lt;number&amp;gt;(0); const windowSize = useWindowSize(); const [enabled, setEnabled] = useState&amp;lt;boolean&amp;gt;(false); useEffect(() =&amp;gt; { let cancelled = false; const { current: sContent } = refItemArea; const getWidth = () =&amp;gt; { if ( !sContent || sContent.clientWidth === logos.length * LOGO_MARGIN_WIDTH * 2 ) { if (!cancelled) { requestAnimationFrame(getWidth); } } else { setEnabled(windowSize.width &amp;lt; sContent.clientWidth); } }; getWidth(); return () =&amp;gt; { cancelled = true; }; }, [logos.length, windowSize]); useAnimationFrame( enabled, useCallback(() =&amp;gt; { const { current: sContainer } = refSliderContainer; const { current: sContent } = refItemArea; if (sContainer &amp;amp;&amp;amp; sContent) { refScrollX.current += 0.5; sContainer.scrollLeft = refScrollX.current; if (sContainer.scrollLeft &amp;gt;= sContent.clientWidth) { refScrollX.current = 0; sContainer.scrollLeft = 0; } } }, []), ); return ( &amp;lt;SliderContainer ref={refSliderContainer}&amp;gt; &amp;lt;SliderArea className=&quot;logo-slider&quot; style= &amp;gt; &amp;lt;LogoArea ref={refItemArea}&amp;gt; {logos.map((src) =&amp;gt; ( &amp;lt;Slide key={`${src}-main`} src={src} /&amp;gt; ))} &amp;lt;/LogoArea&amp;gt; {enabled ? ( &amp;lt;LogoArea style=&amp;gt; {logos.map((src) =&amp;gt; ( &amp;lt;Slide key={`${src}-append`} src={src} /&amp;gt; ))} &amp;lt;/LogoArea&amp;gt; ) : null} &amp;lt;/SliderArea&amp;gt; &amp;lt;/SliderContainer&amp;gt; );};export default Slider;styled-component를 통해서 간략하게 꾸미고 자동 스크롤을 구현하였습니다. 스크롤 로직은 다음과 같습니다. const refSliderContainer = useRef&amp;lt;HTMLDivElement&amp;gt;(null); const refItemArea = useRef&amp;lt;HTMLDivElement&amp;gt;(null); const refScrollX = useRef&amp;lt;number&amp;gt;(0); const windowSize = useWindowSize(); const [enabled, setEnabled] = useState&amp;lt;boolean&amp;gt;(false); refSliderContainer: 스크롤을 담당하는 컴포넌트의 최상단 부분을 참조해야 하므로 useRef로 값을 불러옵니다. refItemArea: 실제로 자동으로 스크롤이 될 부분 중 진짜 이미지를 갖고 있는 부분을 의미합니다. 진짜 이미지의 의미는 잠시 후에 설명드리겠습니다. refScrollX: 스크롤이 X축 방향으로 얼마나 움직였는지를 의미합니다. windowSize: 아까 저희가 만든 useWindowSize 훅을 통해서 width 값을 가져오기 위해서 사용될 예정입니다. enabled: 화면의 크기에 따라서 슬라이드 애니메이션이 나오잖아요? 만약에 enabled 되면 슬라이드 애니메이션을 보여주고 아닐 경우에는 보여주지 않습니다. useEffect(() =&amp;gt; { let cancelled = false; const { current: sContent } = refItemArea; const getWidth = () =&amp;gt; { if ( !sContent || sContent.clientWidth === logos.length * LOGO_MARGIN_WIDTH * 2 ) { if (!cancelled) { requestAnimationFrame(getWidth); } } else { setEnabled(windowSize.width &amp;lt; sContent.clientWidth); } }; getWidth(); return () =&amp;gt; { cancelled = true; }; }, [logos.length, windowSize]);이미지는 useEffect 내부에 useRef를 통해서 width, height의 값을 불러올 경우 컴포넌트가 랜더링 된 이후에 이미지가 로딩이 되므로 크기가 제대로 출력이 안 될 수 있습니다. 이 때문에, 로고(이미지) 개수 * Margin값 * 2를 통해서 이미지가 하나도 불러오지 않았을 때의 길이가 현재 refItemArea의 길이와 동일하거나 useRef를 통해서 값을 제대로 참조하지 못할 경우에는 이를 게속 반복하게 합니다. 그리고 만약에 이미지가 성공적으로 불러와졌으면 현재 화면의 가로 길이가 모든 이미지의 가로 길이 + 마진 값 (즉 ItemArea의 가로 길이)보다 작은지 큰지를 enabled에 넣어줍니다. useAnimationFrame( enabled, useCallback(() =&amp;gt; { const { current: sContainer } = refSliderContainer; const { current: sContent } = refItemArea; if (sContainer &amp;amp;&amp;amp; sContent) { refScrollX.current += 0.5; sContainer.scrollLeft = refScrollX.current; if (sContainer.scrollLeft &amp;gt;= sContent.clientWidth) { refScrollX.current = 0; sContainer.scrollLeft = 0; } } }, []), );이후에는 enabled일 경우에는 이미지를 계속 0.5만큼 좌측으로 이동을 시킵니다. 그러다가 만약에 이미지가 전부 밖으로 나가면 위치를 다시 0으로 바꿔줍니다. return ( &amp;lt;SliderContainer ref={refSliderContainer}&amp;gt; &amp;lt;SliderArea className=&quot;logo-slider&quot; style= &amp;gt; &amp;lt;LogoArea ref={refItemArea}&amp;gt; {logos.map((src) =&amp;gt; ( &amp;lt;Slide key={`${src}-main`} src={src} /&amp;gt; ))} &amp;lt;/LogoArea&amp;gt; {enabled ? ( &amp;lt;LogoArea&amp;gt; {logos.map((src) =&amp;gt; ( &amp;lt;Slide key={`${src}-append`} src={src} /&amp;gt; ))} &amp;lt;/LogoArea&amp;gt; ) : null} &amp;lt;/SliderArea&amp;gt; &amp;lt;/SliderContainer&amp;gt; );그리고 만약에 enabled일 때는 동일한 이미지들을 한 번 더 오른쪽에 생성하고(가짜 이미지) 아닐 때는 진짜 이미지만 표시합니다. 이 부분을 그림으로 설명하면 아래와 같습니다.이미지 설명결론레퍼런스devaslife" }, { "title": "[Python] Selenium으로 원하는 웹사이트 스크린샷 찍기", "url": "/posts/save-screenshot-by-webdriver/", "categories": "Develop, Python", "tags": "Python, Webdriver, Selenium, Screenshot", "date": "2022-05-17 15:43:00 +0900", "snippet": "시작하기에 앞서최근에 프로젝트를 진행하면서 웹사이트의 특정 노트, 혹은 웹사이트 전체를 스크린샷을 찍어 저장해야 하는 상황이 생겼습니다. 파이썬으로 웹사이트를 캡쳐하는 방법은 다양하나, 저는 이번에 Selenium을 활용하여 스크린샷을 찍는 방법을 택하였습니다.Selenium 설치 및 Chromedriver 다운로드이 부분은 Selenium을 써본 적이 없는 분들을 위해서 적으려고 합니다. Selenium을 사용할 수 있고 Chromedriver를 이미 다운로드하신 분은 스크린샷 찍기로 넘어가주시면 됩니다. pip를 통해서 Selenium을 설치합니다. $ pip3 install selenium 자신의 버전에 맞는 Chromedriver를 링크에서 다운 받습니다. 다운 받은 Chromedriver를 자신의 프로젝트로 옮깁니다.스크린샷 찍기본 포스트에서는 기본 스크린샷 찍기, 전체 화면 스크린샷 찍기, 특정 요소(노드) 스크린샷 찍기로 나누어 스크린샷을 찍는 방법을 알아보겠습니다.1. 기본 설정일단 스크린샷을 찍기 전에 Selenium을 통해서 웹 드라이버를 설정해야 합니다. 저는 아래와 같이 설정했으며, 원하시는 입맛대로 수정하시면 됩니다.from selenium import webdriverDRIVER = &#39;자신의 chromedriver 위치&#39; # &#39;chromedriver&#39;, &#39;./driver/chromedriver&#39; 등options = webdriver.ChromeOptions()options.headless = True # 크롬 창을 띄우지 말고 숨기기driver = webdriver.Chrome(DRIVER, options=options)driver.get(&#39;원하는 웹사이트 URI&#39;)저는 이번에 네이버를 스크린샷 찍어보겠습니다.2. 스크린샷2-1. 기본 스크린샷 찍기그냥 기본적으로 스크린샷을 찍는 방법은 매우 간단합니다. Selenium에서 제공하는 save_screenshot() 메서드를 통해서 쉽게 스크린샷을 찍을 수 있습니다.driver.save_screenshot(&#39;filename 혹은 path&#39;) # &#39;screenshot.png&#39;, &#39;./temp/screenshot.png&#39; 등위 메서드를 통해서 스크린샷을 찍으면 다음과 같은 결과물을 얻습니다.말 그대로 Selenium에서 표시되고 있는 화면을 스크린샷을 찍었기에 해당 웹사이트를 보여주는 섬네일 사진으로 활용하기에 적합해 보입니다.2-2. 전체 화면 스크린샷 찍기하지만 위와 같은 상황이 아니라 해당 페이지의 전체를 스크린샷으로 찍고 싶을 때도 있을 것입니다. 이러한 상황에서는 다음 코드를 통해서 스크린샷을 찍을 수 있습니다.from selenium.webdriver.common.by import Byoriginal_size = driver.get_window_size()required_width = driver.execute_script(&#39;return document.body.parentNode.scrollWidth&#39;)required_height = driver.execute_script(&#39;return document.body.parentNode.scrollHeight&#39;)driver.set_window_size(required_width, required_height)# driver.save_screenshot(&#39;filename 혹은 path&#39;) # 스크롤바를 포함하고 찍고 싶을 경우driver.find_element(by=By.TAG_NAME, value=&#39;body&#39;).screenshot(&#39;filename 혹은 path&#39;) # 스크롤바를 제외하고 찍고 싶을 경우driver.set_window_size(original_size[&#39;width&#39;], original_size[&#39;height&#39;])스크롤바를 넣고 싶은 경우에는 driver.save_screenshot()를 사용하시고, 스크롤바를 제외하고 싶을 경우에는 driver.find_element(by=By.TAG_NAME, value=&#39;body&#39;).screenshot()를 사용해서 스크린샷을 찍으면 됩니다.추가적으로, deprecated 됐지만, driver.find_element() 대신 driver.find_element_by_tag_name()을 사용하셔도 동일하게 screenshot() 메서드를 호출할 수 있습니다.해당 코드의 로직은 다음과 같습니다. 현재 Selenium에서 보여주는 화면의 크기를 구합니다. 웹사이트의 body 크기를 구하여 Selenium의 화면 크기를 body 크기로 변경합니다. body 태그를 통해서 element를 구한 뒤에 스크린샷을 찍습니다. 다시 화면 크기를 이전으로 변경합니다. 위 코드를 통해서 스크린샷을 찍으면 다음과 같은 결과물을 얻습니다.다음과 같이 네이버 웹사이트 전체를 저장한 것을 확인할 수 있습니다.2-3. 특정 요소(노드) 스크린샷 찍기마지막으로, 특정 요소(Element)를 저장하고 싶을 경우도 있을 텐데요, 이 때도 전체화면 스크린샷 찍기와 거의 유사한 경우로 스크린샷을 찍을 수 있습니다.저는 네이버에서 검색창 부분만 스크린샷을 해보겠습니다. 또한, 검색창 부분의 클래스가 search_area인 것을 생각하여 클래스로 접근하여 스크린샷을 하겠습니다.from selenium.webdriver.common.by import Byoriginal_size = driver.get_window_size()required_width = driver.execute_script(&#39;return document.body.parentNode.scrollWidth&#39;)required_height = driver.execute_script(&#39;return document.body.parentNode.scrollHeight&#39;)driver.set_window_size(required_width, required_height)driver.find_element(by=By.CLASS_NAME, value=&#39;search_area&#39;).screenshot(&#39;filename 혹은 path&#39;)driver.set_window_size(original_size[&#39;width&#39;], original_size[&#39;height&#39;])위 코드를 통해서 확인할 수 있듯이, 전체화면을 스크린샷 찍을 때랑 선택한 element만 다르게 해서 특정 부위만 스크린 샷을 찍을 수 있었습니다.위 코드를 통해서 스크린샷을 찍으면 다음과 같은 결과물을 얻습니다.딱 저희가 원하는 검색창만 가져온 것을 확인할 수 있습니다.3. Driver 종료하기스크린샷을 전부 찍은 후에는 Selenium을 다음 코드를 통해서 종료하면 됩니다.driver.quit()스크린샷을 찍는 클래스위 내용을 종합하여 저는 아래와 같이 클래스를 만들어서 사용하고 있으니 참고하셔도 좋을 것 같습니다!# screenshot.pyfrom selenium import webdriverfrom selenium.webdriver.common.by import Byclass Screenshot: def __init__(self, driver_path=&#39;chromedriver&#39;): DRIVER = driver_path options = webdriver.ChromeOptions() options.headless = True self.driver = webdriver.Chrome(DRIVER, options=options) def __del__(self): self.driver.quit() def save_screenshot(self, uri: str, file_name: str, path: str = &#39;./temp&#39;, element_class: str = None) -&amp;gt; None: self.driver.get(uri) required_width = self.driver.execute_script(&#39;return document.body.parentNode.scrollWidth&#39;) required_height = self.driver.execute_script(&#39;return document.body.parentNode.scrollHeight&#39;) self.driver.set_window_size(required_width, required_height) if element_class is None: self.driver.fine_element(by=By.TAG_NAME, value=&#39;body&#39;).screenshot(&#39;{}/{}&#39;.format(path, file_name)) else: self.driver.fine_element(by=By.CLASS_NAME, value=element_class).screenshot(&#39;{}/{}&#39;.format(path, file_name))해당 클래스는 다음과 같이 활용할 수 있습니다.from YOUR_PATH import Screenshotc = Screenshot()c.save_screenshot(&quot;https://www.naver.com&quot;, &quot;searchbar.png&quot;, path=&#39;.&#39;, element_class=&#39;search_area&#39;)c.save_screenshot(&quot;https://www.naver.com&quot;, &quot;fullscreen.png&quot;)결론ReferencesTake screenshot of full page with Selenium Python with chromedriver - Stack Overflow" }, { "title": "[Blockchain] 스마트 컨트랙트 이해하기", "url": "/posts/understanding-smart-contract/", "categories": "Develop, Blockchain", "tags": "Blockchain, Smart Contract", "date": "2022-05-12 17:01:00 +0900", "snippet": "시작하기에 앞서본 내용은 블록체인 인 액션 서적을 읽으며 작성하였습니다. 이전에 작성된 내용을 확인하고 싶으신 경우, Blockchain 카테고리를 참고해주세요.스마트 컨트랙트스마트 컨트랙트는 암호 화폐 프레임워크를 신뢰 프레임워크로 전환시켜, 보다 폭넓은 영역에서 탈중앙화 애플리케이션을 활용할 수 있게 해주는 블록체인의 핵심적인 컴포넌트입니다.구조적으로 스마트 컨트랙트는 객체지향 프로그래밍을 할 때 볼 수 있는 클래스와 유사하게 생긴 독립적인 코드입니다. 추가적으로, 데이터와 함수를 가진 배포 가능한 코드 모듈이기도 합니다.현실에서는 컨트랙트는 규칙, 조건, 법, 강제해야 하는 규정, 기준, 상황, 날짜 및 서명 같은 증명을 위한 항목등을 다루는데, 블록체인에서의 스마트 컨트랙트 역시 탈중앙화 문제들을 풀기 위한 컨트랙트 규칙들을 구현합니다. 스마트 컨트랙트는 애플리케이션의 규칙과 규정들을 디지털로 정의하고, 검증하고, 검사하며, 강제하기 위한 블록체인에서 작동시킬 수 있는 실행 가능한 코드다. 스마트 컨트랙트는 제삼자 없이도 신뢰할 수 있는 트랜잭션의 수행을 지원한다. 이런 트랜잭션은 추적 가능하고 되돌릴 수 없다. 블럭체인 인 액션 p.26스마트 컨트랙트 개념스마트 컨트랙트는 비트코인 블록체인 프로토콜이 제공했던 기본적인 신뢰를 확장시키는 코드입니다. 이러한 스마트 컨트랙트는 암호 화폐 이외의 디지털 자산을 위한 트랜잭션을 지원할 수 있는 프로그래밍을 가능하게 해줍니다.블록체인의 차별화된 근본적인 개념에서도 한 번 살펴본 블록체인 애플리케이션 레이어 사진을 다시 가져와봤습니다. 스마트 컨트랙트는 위 그림에서 확인할 수 있듯이 블록체인 노드의 가상머신 위에서 실행이 되면서 샌드박스 환경에 배포되고, 블록체인 네트워크의 참여자들을 식별하는 데 사용하는 160비트의 어카운트 주소를 사용하여 식별합니다.비트코인 트랜잭션 vs 스마트 컨트랙트 트랜잭션암호 화폐 트랜잭션과 비화폐적인 애플리케이션 종속적인 함수 호출 간의 차이를 이해하기 위해서 예제로 가져온 위 사진을 살펴보도록 합니다.비트코인의 경우, 모든 트랜잭션의 가치(Tx(sendValue))를 전송하기 위한 것입니다. 반면, 스마트 컨트랙트를 지원하는 블록체인의 경우, 트랜잭션은 스마트 컨트랙트가 구현한 기능을 임베드합니다. 위 그림을 살펴보면 validateVote(), vote(), count(), declareWinner() 함수가 있네요.스마트 컨트랙트에 있는 위 함수들을 호출하면 블록체인에 기록될 트랜잭션들(Tx(validateVoter), Tx(vote) 등)을 생성합니다. 이렇게 블록체인에 임의로 제작한 코드를 올리고 실행할 수 있는 기능은 단순한 암호 화폐 전송을 넘어서 블록체인의 활용도를 크게 향상시킵니다.스마트 컨트랙트가 하는 일스마트 컨트랙트는 블록체인 애플리케이션의 두뇌와 같은 역할을 수행합니다. 그 중 핵심적인 내용을 나열하면 다음과 같습니다. 각 애플리케이션의 특수한 조건에 맞는 확인과 검증을 할 수 있는 비즈니스 로직 레이어를 표현한다. 블록체인에서 작동하기 위한 규칙의 명세(specification of rules) 를 설정할 수 있게 한다. 탈중앙화 네트워크에서 자산의 전송을 위한 정책을 구현하기 쉽도록 한다. 메시지나 다른 함수의 호출에 의해 실행되는 함수를 내장하는데, 개인 어카운트나 다른 스마트 컨트랙트 어카운트가 이러한 호출을 합니다. 이 메시지는 블록체인의 분산 장부에 트랜잭션 일부로 기록되는데, 여기에는 입력 파라미터, 송신자의 주소, 타임스탬프 등과 같은 추가적인 메타 데이터를 포함합니다. 탈중앙화 블록체인 기반 애플리케이션을 위한 소프트웨어 기반 중개자로서의 기능을 수행합니다. 스마트 컨트랙트 기능의 구체적인 설정을 통해 블록체인에게 브로그래밍 가능성(programmability) 와 지능성을 제공해줍니다. 결론오늘은 스마트 컨트랙트에 대해서 이해를 하는 시간을 가졌습니다. 다음에는 솔리디티를 통해서 이러한 스마트 컨트랙트를 개발을 맛 볼 예정입니다." }, { "title": "[Git] git-flow-avh를 멋쟁이처럼 쓰는 법", "url": "/posts/git-flow-avh-use-like-cool-dude/", "categories": "Tool, Git", "tags": "Git, Git-Flow", "date": "2022-05-12 00:08:00 +0900", "snippet": "시작하기에 앞서작년에 학교에서 협업을 하면서 git-flow-avh를 통해 Git Flow 브랜치 전략을 활용하여 개발을 진행했습니다.사실 git-flow-avh를 사용하는 처음 사용했을 당시에는 완전 신세계였고 깔끔하게 관리할 수 있다는 것에 감탄을 했었으나 개발을 더 진행하면서 몇 가지 문제를 마주하였습니다.그 중 가장 불편했던 점은 Pull Request -&amp;gt; Merge -&amp;gt; Pull와 같이 PR을 하는 방식으로 Workflow를 활용하고 싶었으나, 인터넷을 찾아보면 feature branch를 예로 들면 git flow feature finish 명령어를 통해서 feature branch를 merge하는 것만 나와있었기 때문에 이러한 형식으로만 사용해야 한다고 생각했었습니다.하지만, git flow feature finish 명령어를 사용하지 않고 Pull Request를 사용하는 Workflow를 최근에 발견하고 사용해보니 너무 마음에 들었고 뭔가 섹시하게 Git을 관리할 수 있었습니다.Git-flow-avhGit-flow-avh는 무엇일까요?혹시라도 git-flow-avh를 모르시는 분이 있을 수 있으니 간략하게 소개하고자 합니다. 이미 알고 계시는 분이라면 아래 Git-flow-avh 활용으로 바로 넘어가시면 됩니다.git-flow는 Vincent Driessen의 브랜칭 모델을 위한 고수준 저장소 작업을 제공하는 git의 확장입니다. 여기서 git-flow에 추가적인 명령을 속도 향상하기 위해서 개발한 것이 git-flow-avh으로 avh는 A Virtual Home을 의미합니다. git-flow AVH Edition is a collection of Git extensions to provide high-level repository operations for Vincent Driessen’s branching model. The AVH Edition adds more functionality to the existing git-flow and several of the internal commands have been rewritten to speed up the software.Git-flow-avh 설치하기git-flow-avh를 설치하는 방법은 아래와 같습니다. Mac OS$ brew install git-flow-avh Windows$ wget -q -O - --no-check-certificate https://raw.github.com/petervanderdoes/gitflow-avh/develop/contrib/gitflow-installer.sh install stable | bash Linux$ apt-get install git-flowGit-flow-avh 둘러보기git-flow-avh를 사용하려는 git 저장소 내에서 아래 명령어를 입력하여 git-flow를 시작할 수 있습니다.$ git flow init또한, git-flow는 다음과 같은 명령어들의 조합으로 브랜치를start, finish, publish, pull할 수 있습니다.더욱 자세한 내용은 git-flow cheatsheet를 통해서 살펴볼 수 있습니다.Git-flow-avh 활용Git-flow-avh를 통해 협업하기앞서 말했듯이, 제가 git-flow-avh를 사용했을 때는 start를 통해서 브랜치를 생성한 후, finish를 통해서 해당 브랜치를 merge 시켰습니다.하지만 이런 방식이 아니라 Pull Request를 하고 싶었는데 이 때는 finish를 하지 않고 다른 방식으로 접근을 해야 합니다. 그 방식은 다음과 같습니다. 개발을 진행한 브랜치를 publish 명령어를 통해서 origin에 push합니다. PR를 생성하고 모든 확인이 끝난 경우 Merge를 합니다. pull 명령어를 통해서 origin에서 pull합니다. 위에 올라온 방식처럼 finish를 사용하지 않고 다른 방식으로 관리를 해도 정상적으로 되는 것을 확인할 수 있습니다.결론git-flow-avh를 사용하면서도 PR를 할 수 있다는 사실을 배우면서 더욱 git-flow-avh에 관심을 가지게 되지 않았나 싶습니다.Referencesgit-flow 시작하기git-flow cheatsheetA successful Git branching modelpetervanderdoes/gitflow-avh: AVH Edition of the git extensions to provide high-level repository operations for Vincent Driessen’s branching model (github.com)" }, { "title": "[Blockchain] 블록체인의 차별화된 근본적인 개념", "url": "/posts/block-chain-differentiation/", "categories": "Develop, Blockchain", "tags": "Blockchain", "date": "2022-05-10 17:28:00 +0900", "snippet": "시작하기에 앞서최근에 NFT 및 코인 개발을 진행할 수도 있는 일이 생겨서 블록체인과 솔리디티를 공부하면서 이해한 내용을 적으려고 합니다.해당 내용은 블록체인 인 액션 서적을 읽으며 작성하였습니다.블록체인의 차별화된 근본적인 개념블록체인 프로그래밍을 진행하기에 앞서 블록체인이 가진 차별화된 네 가지의 근본적인 개념을 알고 있어야합니다. 이 내용은 우리가 객체지향 프로그래밍을 처음 배울 때 클래스와 객체의 개념이 무엇인지 이해해야하는 것처럼 매우 중요하지만 꼭 알고 있어야 합니다.블록체인의 차별화된 네 가지 개념은 아래와 같습니다. 블록체인 인프라 - 블록체인 프로토콜, 스마트 컨트랙트, 애플리케이션을 지원하는 특정한 컴퓨팅 하드웨어와 소프트웨어 스택입니다. 이 인프라의 주 구성 요소는 컴퓨팅 노드와 이들 노드를 연결하는 네트워크입니다. 분산 장부 기술 - 인프라 위에 장부가 있고 모든 참여자의 장부에 트랜잭션과 데이터를 동시에 기록합니다. 장부는 모든 참여자가 동일한 사실을 저장하기에 분산되어 있다고 할 수 있습니다. 각 블록은 이전 블록의 서명과 연결되어 변조 방지가 되기 때문에 변조 불가능(immutable) 합니다. 탈중개 프로토콜 - 탈중앙화 시스템의 참여자들은 상호 간에 연결하고 통신하고 거래하기 위해 동일한 블록체인 프로토콜(모두가 따라야 할 규칙의 집합) 을 사용합니다. 예를 들어서 이더리움과 하이퍼레저는 서로 다른 두 개의 블록체인 프로토콜이라고 할 수 있겠네요. 신뢰 확립자 - 탈중앙화 참여자 시스템은 중앙화된 정부 기관이나 은행과 같은 중개자들이 없기 때문에 중개자 없이도 거버넌스(Governance), 검사, 준수(Compliance) 등에 대한 규칙을 구현하여 거의 자동으로 처리하는 인프라가 필요합니다. 블록체인 소프트웨어는 신뢰 확립자의 역할을 맡게 됩니다. 이제 위에 언급한 네 가지 개념을 더 자세히 알아보도록 하겠습니다.1. 블록체인 인프라블록체인 인프라는 도시를 연결하는 철로나 도로처럼 내재적으로 탈중앙화가 이루어져 있습니다. Dapp을 배포한다는 것은 마치 철로나 도로 위에 기차나 자동차를 배치하는 것과 비슷합니다. 그럼 철로에 기차가 놓여져 있는 것을 생각하면서 인프라에 대해서 더욱 알아볼까요?인프라에 대해서 바로 알아보기에 앞서 말한 탈중앙화 시스템은 무엇일까요? 탈중앙화 시스템이란 분산 시스템의 일종으로 아래와 같은 일이 일어납니다. 참여자들은 P2P로 소통합니다. 참여자들은 디지털이든 아니든 자신의 자산(오디오 파일, 디지털 건강 기록, 또는 토지 등)을 통제합니다. 참여자들은 자신의 의사에 따라 참여하거나 떠날 수 있습니다. 참여자들은 통상의 신뢰 경계(대학이나 나라 등)를 넘어서서 행위를 할 수 있습니다. 결정은 중앙화 기관이 아니라 분산된 참여자들이 내립니다. 블록체인과 같은 자동화된 소프트웨어가 상호 간 중개를 담당합니다. 이러한 탈중앙화 시스템이 필요로 하는 조건을 충족시켜주는 블록체인의 아키텍처적인 요소들도 살펴볼까요?블록체인 노드, 네트워크, 애플리케이션항공 교통을 예로 들어보겠습니다. 모든 비행기는 출발지랑 도착지를 가지고 있고, 경유 공항과 경로가 항공 네트워크를 구성하고 있습니다. 이처럼 블록체인 노드는 트랜잭션의 엔드포인트로서 작동에 필요한 컴퓨팅 환경을 호스팅하고, 트랜잭션을 릴레이하며, 브로드캐스팅하는 기능을 수행합니다.위 그림을 통해 아래에서 위로 올라가면서 단일 블록체인 노드를 구성을 알아봅시다! Computer systems hardware/Network and operating system : 이 두 레벨은 컴퓨팅 시스템이 가진 표준적인 하드웨어랑 소프트웨어를 의미합니다. Blockchain protocol implementation : 블록체인 프로토콜 레이어로 블록체인 컴포넌트들을 포함하고 있습니다. Smart contract on virtual machine : 이 레이어에서는 Application의 로직을 호스팅합니다. 여기에서는 데이터 액세스 컨트롤, 확인, 검증 및 저장을 위한 함수 코딩과 같은 문재들을 해결합니다. Decentralized application : 이 부분은 사용자를 마주하는 인터페이스로 이 부분에서는 웹 프로그래밍이 이루어집니다. 추가적으로, 해당 레이어는 아래와 같이 다른 레이어 구조로도 나타낼 수 있습니다.이러한 블록체인 애플리케이션은 일반적으로 많은 수의 참여자를 노드 네트워크를 통해서 연결하고 각 노드는 이를 이용하는 서로 다른 사용자들을 식별할 수 있는 다수의 어카운트를 지원합니다. 이 때, 하나의 노드는 다수의 Dapp을 호스팅할 수 있습니다. 즉 예를 들어서, 탈중앙화 공급망 관리 시스템 Dapp과 탈중앙화 지급 시스템 Dapp을 동시에 호스팅할 수 있겠네요!다음 그림은 이러한 노드 3개를 네트워크로 연결한 노드 네트워크입니다. 이 네트워크에서는 다음과 같은 것을 브로드캐스팅 할 수 있겠네요. 사용자가 기동한 트랜잭션 트랜잭션들로 이루어진 블록 이러한 트랜잭션과 블록은 네트워크의 페이로드를 구성하며, 최종적으로 확인과 검증을 거쳐 분산된 장부에 기록됩니다.스마트 컨트랙트스마트 컨트랙트는 블록체인 노드가 호스팅하는 가상머신과 같은 샌드박스 환경에서 실행됩니다. 이런 스마트 컨트랙트의 구문은 객체지향 언어의 클래스와 매우 유사하며, 데이터, 함수, 함수를 실행하기 위한 규칙들을 갖고 있습니다. 이러한 스마트 컨트랙트 함수를 호출하거나 실행하면 아래 그림과 같이 블록체인에 기록할 트랜잭션을 생성합니다. 물론, 함수 호출이 확인과 검증 규칙에 위배되면, 함수 호출을 취소합니다.2. 분산 장부 기술1. 블록체인 인프라에서 알아본 이러한 인프라가 지원하는 핵심적인 블록체인 기술은 분산 장부 기술(DLT)입니다. 저희가 알아볼 것은 다음과 같습니다. 블록체인 DLT를 구성하는 요소 트랜잭션을 저장하는 블록을 위한 DLT의 물리적 구조 애플리케이션이 어떻게 의도한 목적(신뢰 구축을 위한 확인, 검증 및 변조 불가능한 저장)을 위해 DLT를 사용하는지에 대한 상세한 작동 과정 DLT의 무결성을 위한 합의 알고리즘 트랜잭션, 블록, 블록의 체인애플리케이션은 트랜잭션과 스마트 컨트랙트 코드 실행을 시작합니다. 즉, 우리가 애플리케이션에서 어카운트 간에 단순한 암호 화폐 송금을 하면 ‘send’라는 트랜잭션이 생성됩니다. 이는 블록체인 네트워크를 통해 트랜잭션을 브로드캐스팅한 후, 변조 불가능한 분산 장부에 기록합니다.이러한 트랜잭션을 블록체인에 저장하는 과정은 아래와 같습니다. 수집한 네트워크의 트랜잭션들은 검증 단계를 거쳐 풀로 모입니다. 노드는 블록을 만들기 위해서 풀에서 트랜잭션들을 골라서 세트로 만들어집니다. 이 때, 트랜잭션들을 고르는 기준은 일반적으로 트랜잭션에 책정된 수수료로, 수수료가 비싼 트랜잭션부터 선택받습니다. 참여한 노드들은 합의 알고리즘을 사용해 기존 체인에 추가될 트랜잭션들을 포함하는 하나의 블록에 대해 집합적으로 합의를 합니다. 체인의 현재 리드 블록을 나타내는 값인 해시를 새롭게 추가될 블록에 더해서 체인 링크를 만듭니다. 트랜잭션이 모여서 블록이 된 뒤에 참여 노드들 간의 합의로 마지막 체인에 추가가 됩니다. 이 때, 새로 참여한 블록 n + 1의 해시에 이전 블록인 n에 저장되어 체인 링크를 만듭니다. 만약에 블록 n을 수정하면 해시 n값 또한 변하는데, 이것이 바로 변조 불가능성을 보장합니다.위 설명에서 짐작을 하셨겠지만, 블록체인은 추가만 허용(Append-only)할 수 있습니다. 이 때문에 변조 불가능성을 보장하는 것이기도 했고요! 그러면 이러한 체인에도 첫 번째 블록이 있을텐데, 그 블록을 제네시스 블록(Genesis Block) 이라고 합니다. 그리고 블록체인에 참여하는 모든 노드는 제네시스 노드로부터 시작해서 모두 동일한 블록체인 복사본들 가지고 있습니다.이 때문에 저희는 블록체인 DLT를 다음과 같은 특징으로 정리할 수 있습니다. 분산되어 있다. : 블록체인 프로토콜은 분산된 각각의 참여 노드들이 동일한 블록의 체인 복사본을 가지고 있다는 것을 보장해주기 때문입니다. 변조가 불가능하다. : 위에서 두 번이나 언급했듯이, 새로 생성되는 모든 블록은 현재 블록체인인 헤드의 해시값을 통해 기존 블록체인에 연결되어 있기 때문에 변조가 불가능합니다. 3. 탈중개 프로토콜교통 인프라와 마찬가지로 블록체인 인프라도 따라야 할 규칙들을 가지고 있습니다. 도로에 있는 자동차를 운전하는 운전자들이 도로 규칙을 따르지 않으면 어마어마한 혼란이 일어나기 때문에 규칙을 지키는 것 처럼 프로토콜이나 규칙의 집합이 블록체인의 구조와 운영(Operation)을 관할합니다. 이러한 블록체인 프로토콜은 주요하게 다음과 같은 것을 규정합니다. 블록체인의 구조(트랜잭션, 블록, 블록의 체인) 암호화, 해싱, 상태 관리를 위한 기반 알고리즘과 표준 블록의 합의와 일관성 있는 체인을 구현하기 위한 방법 불일치하는 장부를 초래할 수 있는 예외들을 처리하는 테크닉 이러한 맥락(Context)에서 일관성, 정확성, 변조 불가능성을 유지하기 위한 블록체인의 코드와 규칙들의 실행 환경 이러한 프로토콜은 대표적으로 비트코인과 이더리움으로 나눌 수 있는데 각 코인의 스택은 다음과 같습니다.4. 신뢰 확립자모든 거래에서 신뢰는 매우 중요합니다. 만약에 저희가 엄청난 금액의 돈을 송금하려면 어떻게 신뢰를 확보할까요? 아마 거래 당사자들의 신용을 확보하기 위해서 은행과 같이 중개자가 필요할 겁니다. 근데 탈중앙화 시스템에는 신분을 확인하는 사람도 없고 은행이 없기 때문에 이를 해결하기 위한 소프트웨서 메커니즘이 필요합니다.여기서 블록체인은 탈중앙화 인프라, 분산 장부 기술, 탈중개 프로토콜인 3D를 충족하여 시스템에 신뢰를 구축합니다.실제로 인터넷과 블록체인 기반 신뢰는 IETF의 RFC를 통해서도 확인할 수 있습니다.결론오늘은 이렇게 블록체인의 주요한 4가지 개념을 알아보았습니다. 코딩을 하는 것이 아니라 CS적인 내용이라 약간 머리가 띵하긴 했지만 그래도 블록체인 자체를 제대로 이해할 수 있었던 시간입니다.다음 글에서는 스마트 컨트랙트를 이해하고 사용해보겠습니다!" }, { "title": "[Git] 항상 GitHub 비밀번호를 요구하는 오류 해결하기", "url": "/posts/fix-git-always-asking-password/", "categories": "Tool, Git", "tags": "Git, Error", "date": "2022-04-30 19:58:00 +0900", "snippet": "시작하기에 앞서GitHub에서 HTTPS를 통해 클론을 해서 프로젝트를 수정한 후 Push를 하려고 하니까 매번 GitHub 계정으로 로그인을 하라는 오류가 떠서 생각 없이 다시 로그인을 하고는 했습니다.하지만 너무 불편해서 인터넷에 검색해보니 생각보다 흔하게 발생하는 오류로 간단하게 해결할 수 있었습니다.오류 해결 방법Origin Remote의 URL을 HTTPS에서 SSH로 수정하기$ git remote set-url origin git@github.com:username/repo.git첫 번째 방법은 origin remote를 HTTPS에서 SSH로 변경하는 것입니다. 해당 오류는 HTTPS에서만 발생하므로 SSH로 연결할 경우 해당 문제를 해결할 수 있습니다.Git Store 활용$ git config --global credential.helper store$ git config --global credential.helper cache$ git config --global credential.helper &#39;cache --timeout=600&#39;두 번째 순서는 Git store와 cache를 활용하는 방법입니다. 위 커맨드는 다음과 같은 의미를 가지고 있습니다. username과 password를 저장하기 위한 Git store를 생성한다. Session의 username과 password를 저장(cache)한다. 필요시, 위 설정에 timeout을 설정한다. 결론보안과 관련된 이유로 사실 Git Store를 활용하여 오류를 해결하는 것보다 SSH를 통해서 GitHub와 통신하는 것이 바람직합니다.저는 아직까지 SSH를 통해서 연결할 생각을 하진 않았었는데 회사에서 일하거나 제 컴퓨터가 아닌 컴퓨터에서 작업을 할 때를 고려하여 SSH로 통신하는 것으로 천천히 바꿔야겠네요. However, due to security reasons, it is advisable that you use SSH to interact with GitHub, especially if you work for a company or you’re using a computer that isn’t yours. Using the SSH protocol, you can connect to GitHub without supplying your username or password every time.ReferencesHow to fix Git always asking for user credentials (freecodecamp.org)" }, { "title": "[Vim] Vim 키 매핑으로 단축키 만들어보기", "url": "/posts/how-to-override-vim-command/", "categories": "Tool, Vim", "tags": "Vim", "date": "2022-04-04 01:35:00 +0900", "snippet": "시작하기에 앞서Vim은 그 자체 만으로도 강력한 텍스트 에디터지만 자신만의 단축키를 만들어서 보다 편하게 사용할 수 있습니다.예를 들어볼까요? Normal모드에서 Insert모드로 바꾸지 않고 새로운 라인을 변경하려면 어떻게 해야할까요? o 혹은 O를 눌러서 새로운 라인을 만들고 Insert모드로 들어간 뒤에 ESC를 눌러서 나오는 방법 말고는 없을 겁니다.이렇게 자신이 자주 사용하는 기능들을 새로운 단축키로 만들면 얼마나 좋을까요? 오늘은 이러한 단축키를 만드는 방법을 알아보도록 하겠습니다.단축키를 만드는 방법.vimrc 혹은 init.vim 접근하기Vim 단축키를 추가하는 방법 역시, .vimrc나 init.vim을 수정 및 저장 해주면 됩니다. 이는 사용하는 Vim 종류에 따라서 바뀌니 자신에게 맞는 명령어를 입력해주면 됩니다. 사용하는 Vim이 일반적인 Vim인 경우 $ vim ~/.vimrc 사용하는 Vim이 Neovim인 경우 $ nvim ~/.config/nvim/init.vim 단축키 조합기본 모습map {lhs} {rhs}&quot; 예제: F3 키를 o를 누른 뒤 ESC를 누르는 것으로 대치map &amp;lt;F3&amp;gt; o&amp;lt;ESC&amp;gt;Vim 키 매핑은 위와 같은 기본 모습을 가집니다. map 이후에는 새로 만들 단축키를 넣어주고 그 이후에는 그 단축키로 매핑될 값을 입력합니다.map의 종류map은 모드 종류와 Recursive 여부에 따라서 수정이 가능합니다.일단 모드 종류에 따른 매핑 조합을 알아보겠습니다. 값 모드 한국어 빈 공간 normal, visual, select, operator-pending 모든 모드 n normal mode 노멀 모드 v visual, select mode 비주얼 모드 x visual mode only 비주얼 모드 s select mode only 선택 모드 i insert mode 편집 모드 c command-line mode 커맨드라인 모드 l insert, cmd, RegEx mode Lang-Arg 모드 o operator-pending mode Pending 모드 여기서 저희가 주로 사용하는 모드는 normal, visual, insert 이므로 n, v, i만 생각하고 나머지는 이런게 있구나 정도로만 아시면 될 것 같습니다.다음은 Recursive 여부에 따른 매핑 조합입니다. Recursive 여부는 모드 종류 이후에 적습니다. 값 모드 한국어 re Recursive Recursive 매핑 nore Non-Recursive Recursive 매핑 안 함. Recursive는 재귀하는 것을 의미할텐데 그러면 Vim에서의 Recursive는 도대체 뭘까요? 아래 예제로 한 번 확인을 해보겠습니다.&quot; Recursivemap o imap i e위와 같이 매핑을 하면 어떻게 될까요? o키는 i키를 매핑할거고, i키는 e키를 매핑하기 때문에 o -&amp;gt; i -&amp;gt; e로 최종적으로 o키를 눌렀을 때는 e키를 눌렀을 때와 동일한 동작을 하게 됩니다.하지만, 이러한 상황이 아니라 o를 눌렀을 때는 i를 눌렀을 때 처럼 Insert 모드로 들어가고 i를 눌렀을 때는 다음 단어로 넘어가는 e 기능을 넣고 싶을 떄는 어떻게 해야할까요? 이 때는 바로 Non-Recursive하게 키를 매핑해주면 됩니다.&quot; Non-Recursivenoremap o inoremap i e위와 같이 해주면 저희가 원하는 대로 동작할 겁니다!단축키 조합그러면 이제 모드 종류와 recursive 종류를 조합한 예를 적겠습니다.&quot; Normal 모드에서 Non-Recursive하게 a를 i로 매핑nnoremap a i&quot; Insert 모드에서 Non-Recursive하게 Ctrl + n을 :tabnew로 매핑inoremap &amp;lt;C-n&amp;gt; :tabnew&amp;lt;CR&amp;gt;&quot; 모든 모드에서 Ctrl-a로 :NERDTreeToggle을 매핑noremap &amp;lt;C-a&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt;이처럼 자신의 입맛에 맞춰서 키를 매핑할 수 있습니다.특수 키일반적인 알파벳이나 숫자가 아니라 Ctrl이나 Alt키와 같이 특수 키들을 매핑하고 싶을 때가 있습니다. 이 때는 아래 표에서 원하는 키를 찾아서 이를 삽입해주면 됩니다. 키 명 키 값 ESC &amp;lt;ESC&amp;gt; Space &amp;lt;Space&amp;gt; Tab &amp;lt;Tab&amp;gt; Enter &amp;lt;CR&amp;gt; F1~12 &amp;lt;F1&amp;gt; &amp;lt;F2&amp;gt; ... &amp;lt;F12&amp;gt; Ctrl 조합 &amp;lt;C-a&amp;gt; &amp;lt;C-b&amp;gt; ... &amp;lt;C-Z&amp;gt; &amp;lt;C-Space&amp;gt; &amp;lt;C-Tab&amp;gt; ... Alt 조합 &amp;lt;A-a&amp;gt; &amp;lt;A-b&amp;gt; ... &amp;lt;A-Z&amp;gt; &amp;lt;A-Space&amp;gt; &amp;lt;A-Tab&amp;gt; ... Shift 조합 &amp;lt;S-a&amp;gt; &amp;lt;S-b&amp;gt; ... &amp;lt;S-Z&amp;gt; &amp;lt;S-Space&amp;gt; &amp;lt;S-Tab&amp;gt; ... Ctrl + Alt 조합 &amp;lt;C-A-a&amp;gt; &amp;lt;C-A-b&amp;gt; ... &amp;lt;C-A-Z&amp;gt; &amp;lt;C-A-Space&amp;gt; &amp;lt;C-A-Tab&amp;gt; ... Ctrl + Alt + Shift 조합 &amp;lt;C-A-S-a&amp;gt; &amp;lt;C-A-S-b&amp;gt; ... &amp;lt;C-A-S-Z&amp;gt; &amp;lt;C-A-S-Space&amp;gt; &amp;lt;C-A-S-Tab&amp;gt; ... 기타 특수 케이스 조용히 처리를 하고 싶을 때nnoremap &amp;lt;C-a&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt;위와 같이 Ctrl + a를 눌렀을 때 너드 트리가 출력되게 하고 싶다고 합시다. 그리고 직접 이 단축키를 눌러보면 하단 커맨드를 입력하는 부분에 :NERDTreeToggle이라고 제가 실행한 단축키가 출력이 됩니다.하지만 이런게 마음에 들지 않고 숨기고 싶다면 명령어 조합 전에 &amp;lt;Silent&amp;gt;를 입력해주면 됩니다.nnoremap &amp;lt;Silent&amp;gt; &amp;lt;C-a&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt; 키 매핑을 삭제하고 싶을 때키 매핑을 새로 만드는 것이 아니라 매핑을 취소하고 싶은 경우가 있을 겁니다. 예를 들어, &amp;lt;C-r&amp;gt; 키를 다른 용도로 사용하고 있어 기존 용도를 없애버리고 싶거나, 매핑을 없애버리고 싶은 경우, unmap을 사용하면 됩니다.unmap &amp;lt;C-r&amp;gt; 사용자 전용 키Vim에서는 사용자가 원하는 키를 등록하는 &amp;lt;Leader&amp;gt;키를 제공하고 있습니다. 기본적으로 \\ (백슬래시키)로 설정이 되어있으며 다른 특수 키와 동일하게 키 조합으로 사용할 수 있습니다.nnoremap &amp;lt;Silent&amp;gt; &amp;lt;Leader&amp;gt;[ :tabprevious&amp;lt;CR&amp;gt;이 &amp;lt;Leader&amp;gt;키가 다른 특수 키보다 더 특별한 이유는 키를 백슬래시에서 다른 키로 변경할 수 있기 때문입니다, 변경하는 방법은 다음과 같습니다.let mapleader=&quot;다른 키&quot;&quot; 예제: leader를 \\에서 .로 바꿀 경우let mapleader=&quot;.&quot;결론오늘은 이와 같이 Vim 키 매핑을 알아봤습니다. 자신에게 맞는 키 매핑을 적용하여 더욱 효율적인 코드 개발을 하셨으면 좋겠습니다! :)참조밤앙개 블로그 - 디자인과 개발 : 네이버 블로그 (naver.com)" }, { "title": "[Flutter] BLoC 패턴을 케이크처럼 쉽게 이해할 수 있는 글", "url": "/posts/learn-bloc-like-eating-cake/", "categories": "Develop, Flutter", "tags": "Flutter, BLoC", "date": "2022-02-19 20:50:00 +0900", "snippet": "Before Start.이 포스트에서는 BLoC 패턴을 이해하기 어려운 개발자 분들에게 매우 쉽게 BLoC을 풀어서 설명하려고 합니다.그래서 BLoC 패턴이 도대체 뭐야?BLoC은 Business Logic Component로 구글 개발자가 개발한 상태관리 아키텍처 패턴입니다.이 부분은 다른 블로그에서 쉽게 찾아볼 수 있으므로 길게 설명하지 않겠습니다.BLoC 패턴을 써야하는 이유솔직히 크기가 작은 앱을 개발하다보면 아키텍처 패턴과 상태관리가 별로 중요한 것처럼 느껴지지 않습니다.하지만 개발하는 앱의 사이즈가 커질수록 아키텍처 패턴과 상태관리는 매우 중요한 부분 중 한 곳을 차지하며 보다 멋있는 개발자가 되기 위해서는 꼭 필요한 요소 중 하나라고 생각합니다.또한 비즈니스 로직과 UI를 분리했기 때문에 코드가 상당히 깔끔해지고 보기 좋아집니다.이번 포스트에서 만들어 볼 프로젝트BLoC 패턴을 통해서 pub.dev에 올라온 패키지들을 크롤링하여 리스트로 출력하는 프로젝트를 만들어보겠습니다.References아래 링크에 완성된 코드를 올려놨으니 참고하시면서 보면 이해하기 훨씬 쉬울겁니다.devappmin/BLoC_PracticeGetting Started.BLoC 패턴의 모습BLoC패턴은 위 그림 한 장으로 설명이 가능합니다.쉽게 이해가 안 갈 수도 있으니 이번에 저희가 만들 pub.dev 크롤링 앱 개발을 예로 들어보겠습니다. events 화면이 띄어졌을 때 pub.dev에 있는 패키지를 불러오기. FAB을 눌러서 현재 패키지 리스트에다가 값 추가로 불러오기. states 패키지가 없고 빈 상태일 때 (Empty) 크롤링을 통해서 값을 가져오는 중이라 로딩 중일 때 (Loading) 값을 성공적으로 불러왔을 때 (Loaded) 값을 불러오던 도중 에러가 발생했을 때 (Error) request / response 크롤링을 하기 위해서 웹에 요청을 하고 해당 값을 불러왔을 때 사용할 패키지이번 프로젝트를 진행하기 위해서 사용한 패키지는 다음과 같습니다. http html flutter_bloc equatable build_runner freezed json_serializable프로젝트 구조lib│ main.dart│├───bloc│ package_bloc.dart│ package_event.dart│ package_state.dart│├───domain│ ├───colors│ │ colors.dart│ ││ └───constant│ pub_dev.dart│ score_value.dart│├───model│ package.dart│ package.freezed.dart│ package.g.dart│└───repository package_repository.dart이제 차근차근 개발을 진행해보겠습니다.Code it.Domaincolors/colors.dartimport &#39;package:flutter/widgets.dart&#39;;class ViewColors { static const Color primaryColor = Color(0xFF0175c2); static const Color primaryDarkColor = Color(0xFF00539b); static const Color primaryTextColor = Color(0xFF4A4A4A); static const Color secondaryTextColor = Color(0xFF6d7278);}colors/colors.dart에는 제가 사용하고 싶은 색깔들을 저장했습니다.constant/pub_dev.dartclass PubDev { static const String pubDevUrl = &#39;https://pub.dev/packages&#39;; static const String packageQuery = &#39;?page=&#39;; static Uri packageUrl(int page) =&amp;gt; Uri.parse(pubDevUrl + packageQuery + page.toString());}pub.dev에서 크롤링하기 위해서 링크를 저장했습니다. page 쿼리에 따라서 페이지가 이동하기 때문에 페이지 번호를 입력 받으면 Uri를 리턴하는 함수도 하나 생성했습니다.constant/score_value.dartclass ScoreValue { static const String likes = &quot;LIKES&quot;; static const String pubPoints = &quot;PUB POINTS&quot;; static const String popularity = &quot;POPULARITY&quot;;}따봉 / pub 점수 / 인기도 스트링을 저장해놓은 클래스입니다.ModelModel은 저희가 pub.dev에서 가져올 패키지에서 필요한 값을 저장할 package.dart를 생성했습니다.package.dartimport &#39;package:freezed_annotation/freezed_annotation.dart&#39;;part &#39;package.freezed.dart&#39;;part &#39;package.g.dart&#39;;@freezedclass Package with _$Package { factory Package({ required String name, required String description, required String version, required bool nullSafety, required int likes, required int pubPoints, required int popularity, }) = _Package; factory Package.fromJson(Map&amp;lt;String, dynamic&amp;gt; json) =&amp;gt; _$PackageFromJson(json);}패키지에서 가져올 값은 아래와 같습니다. name: 패키지의 이름 description: 패키지의 상세 내용 version: 패키지 버전 nullSafety: Null Safety 여부 likes: 따봉 개수 pubPoints: Pub 점수 popularity: 인기도또한 package.dart는 freezed를 통해서 Model을 생성할 것이기 때문에 with _$Package를 넣어주고 JSON을 통해서 값을 불러올 것이기 때문에 fromJson을 생성합니다.그 후에는 아래 커맨드를 통해서 package.freezed.dart와 package.g.dart를 생성합니다.$ flutter pub run build_runner build이를 통해서 Model 생성을 완료하였습니다.RepositoryRepository는 Web에서 데이터를 가져오고 이를 처리하는 것을 담당합니다.이번 프로젝트에서는 크롤링을 통해서 값을 가져오고 리턴하는 부분이 필요하겠네요!package_repository.dartimport &#39;package:bloc_practice/domain/constant/pub_dev.dart&#39;;import &#39;package:html/dom.dart&#39;;import &#39;package:html/parser.dart&#39; as parser;import &#39;package:http/http.dart&#39; as http;class PackageRepository { Future&amp;lt;List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt;&amp;gt; getPackages(int page) async { // Get the packages list with the given page number on pub.dev final response = await http.get( PubDev.packageUrl(page), headers: { &#39;Accept&#39;: &#39;application/json&#39;, }, ); // Check if the response is successful if (response.statusCode == 200) { Document document = parser.parse(response.body); List&amp;lt;Element&amp;gt; packageElements = document.querySelectorAll(&#39;.packages-item&#39;); List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; packages = []; for (var pkgs in packageElements) { Element? name = pkgs.querySelector(&#39;.packages-title&#39;); Element? description = pkgs.querySelector(&#39;.packages-description&#39;); Element? version = pkgs.querySelector(&#39;.packages-metadata-block&#39;); Element? nullSafety = pkgs.querySelector(&#39;.package-badge&#39;); Element? likes = pkgs .querySelector(&#39;.packages-score-like .packages-score-value-number&#39;); Element? pubPoints = pkgs.querySelector( &#39;.packages-score-health .packages-score-value-number&#39;); Element? popularity = pkgs.querySelector( &#39;.packages-score-popularity .packages-score-value-number&#39;); packages.add({ &#39;name&#39;: name?.text, &#39;description&#39;: description?.text, &#39;version&#39;: version?.text, &#39;nullSafety&#39;: nullSafety == null ? false : true, &#39;likes&#39;: int.parse(likes?.text.toString() ?? &#39;0&#39;), &#39;pubPoints&#39;: int.parse(pubPoints?.text.toString() ?? &#39;0&#39;), &#39;popularity&#39;: int.parse(popularity?.text.toString() ?? &#39;0&#39;), }); } return packages; } else { // If the response is not successful, throw an error throw Exception(&#39;Failed to load packages&#39;); } }}pub.dev에서 크롤링을 하고 가져온 패키지들을 리턴하는 함수입니다. 오늘은 크롤링이 아니라 BLoC을 배우는 것이 목적이므로 간단하게 설명하겠습니다.http를 통해서 pub.dev에 요청을 보냅니다. 그 후, parser.parse를 통해서 파싱을 한 다음에 패키지 리스트에 값을 저장하고 이를 리턴합니다.BLoCBLoC 아키텍처는 기본적으로 xxxx_bloc.dart, xxxx_state.dart, xxxx_event.dart(xxxx는 BLoC 이름) 파일을 생성해야 합니다.처음에는 state부터 살펴보겠습니다.package_state.dartpart of &#39;package_bloc.dart&#39;;@immutableabstract class PackageState extends Equatable {}class Empty extends PackageState { @override List&amp;lt;Object?&amp;gt; get props =&amp;gt; [];}class Loading extends PackageState { @override List&amp;lt;Object?&amp;gt; get props =&amp;gt; [];}class Loaded extends PackageState { final List&amp;lt;Package&amp;gt; packages; Loaded({required this.packages}); @override List&amp;lt;Object?&amp;gt; get props =&amp;gt; [packages];}class Error extends PackageState { final String message; Error({required this.message}); @override List&amp;lt;Object?&amp;gt; get props =&amp;gt; [message];}package_event.dart는 패키지를 불러오는 상태를 관리하는 클래스들을 저장합니다.일단 모든 클래스의 부모가 되는 PackageState abstract 클래스를 생성하고 Equatable을 상속받습니다.Equatable가 뭔지 모르시면 [Flutter] Equatable, 이렇게 좋은데도 안 써?를 참조해주세요.저희는 위에 언급했듯이 4개의 state를 생성할 것입니다. 패키지가 없고 빈 상태일 때 (Empty) 크롤링을 통해서 값을 가져오는 중이라 로딩 중일 때 (Loading) 값을 성공적으로 불러왔을 때 (Loaded) 값을 불러오던 도중 에러가 발생했을 때 (Error)Loaded 상태에서는 불러온 패키지의 리스트를 가져올 수 있게 하였고, Error가 발생했으면 에러 메시지를 가지고 올 수 있게 하였습니다.package_event.dartpart of &#39;package_bloc.dart&#39;;@immutableabstract class PackageEvent extends Equatable {}class GetPackageEvent extends PackageEvent { final int pages; GetPackageEvent({ required this.pages, }); @override List&amp;lt;Object?&amp;gt; get props =&amp;gt; [pages];}class AppendPackageEvent extends PackageEvent { final int pages; AppendPackageEvent({ required this.pages, }); @override List&amp;lt;Object?&amp;gt; get props =&amp;gt; [pages];}package_event.dart역시 Equatable을 상속받은 PackageEvent를 통해서 두 개의 이벤트를 생성해줍니다.이 또한 위에서 언급했듯이 아래 두 기능을 구현하기 위해서 사용하려고 합니다. 화면이 띄어졌을 때 pub.dev에 있는 패키지를 불러오기. (GetPackageEvent) FAB을 눌러서 현재 패키지 리스트에다가 값 추가(Append)로 불러오기. (AppendPackageEvent)package_bloc.dartimport &#39;package:bloc/bloc.dart&#39;;import &#39;package:bloc_practice/model/package.dart&#39;;import &#39;package:bloc_practice/repository/package_repository.dart&#39;;import &#39;package:equatable/equatable.dart&#39;;import &#39;package:freezed_annotation/freezed_annotation.dart&#39;;part &#39;package_event.dart&#39;;part &#39;package_state.dart&#39;;class PackageBloc extends Bloc&amp;lt;PackageEvent, PackageState&amp;gt; { final PackageRepository packageRepository; PackageBloc({required this.packageRepository}) : super(Empty()) { on&amp;lt;GetPackageEvent&amp;gt;(_onGetPackageEvent); on&amp;lt;AppendPackageEvent&amp;gt;(_onAppendPackageEvent); } void _onGetPackageEvent( GetPackageEvent event, Emitter&amp;lt;PackageState&amp;gt; emit) async { try { emit(Loading()); final resp = await packageRepository.getPackages(event.pages); final packages = resp .map&amp;lt;Package&amp;gt;( (e) =&amp;gt; Package.fromJson(e), ) .toList(); emit(Loaded(packages: packages)); } catch (e) { emit(Error(message: e.toString())); } } void _onAppendPackageEvent( AppendPackageEvent event, Emitter&amp;lt;PackageState&amp;gt; emit) async { try { if (state is Loaded) { final parsedState = (state as Loaded); final resp = await packageRepository.getPackages(event.pages); final packages = resp .map&amp;lt;Package&amp;gt;( (e) =&amp;gt; Package.fromJson(e), ) .toList(); final prevPackages = [ ...parsedState.packages, ]; final newPackages = [ ...prevPackages, ...packages, ]; emit(Loaded(packages: newPackages)); } } catch (e) { emit(Error(message: e.toString())); } }}이제 대망의 BLoC 클래스입니다. 클래스를 하나씩 뜯어보면서 살펴볼까요?class PackageBloc extends Bloc&amp;lt;PackageEvent, PackageState&amp;gt; {클래스를 생성할 때 Bloc&amp;lt;Event 클래스, State 클래스&amp;gt;를 상속 받아줍니다.final PackageRepository packageRepository;저희가 아까 만들었던 pub.dev를 크롤링하는 클래스의 인스턴스를 생성해줍니다. PackageBloc({required this.packageRepository}) : super(Empty()) { on&amp;lt;GetPackageEvent&amp;gt;(_onGetPackageEvent); on&amp;lt;AppendPackageEvent&amp;gt;(_onAppendPackageEvent); }Constructor를 생성해줍니다. 이 떄, super()에 초기 값을 넣어줘야 하는데 저희는 아무 것도 없는 상태를 넣을 것 이므로 Empty를 넣어주겠습니다. 또한, packageRepository를 props로 받고 싶으므로 이를 넣어줍니다.저희는 아직 이벤트를 받으면 처리하는 부분을 만들지 않았잖아요?패키지를 받는 이벤트를 받았으면 이를 처리해주고, 현재 패키지에 새로 받은 패키지를 이어주는 이벤트를 받았으면 이를 처리해주는 로직이 필요한데 아직 저희가 그거를 구현하지 않았거든요.이 부분은 on&amp;lt;GetPackageEvent&amp;gt;();에서 해결이 가능합니다. on의 기본적인 문법은 아래와 같습니다.on&amp;lt;EventName&amp;gt;((event, emit) { // Logic here..});이 말은 즉슨 익명 함수를 밖으로 꺼내서도 사용할 수 있다는 의미겠죠? 저희는 더 깔끔하게 코드를 보기 위해서 로직 부분을 담당하는 함수를 두 개 생성해주고 함수 이름을 대신 적어주도록 합니다. void _onGetPackageEvent( GetPackageEvent event, Emitter&amp;lt;PackageState&amp;gt; emit) async { try { emit(Loading()); final resp = await packageRepository.getPackages(event.pages); final packages = resp .map&amp;lt;Package&amp;gt;( (e) =&amp;gt; Package.fromJson(e), ) .toList(); emit(Loaded(packages: packages)); } catch (e) { emit(Error(message: e.toString())); } }저희가 꺼낸 로직은 다음과 같습니다.함수를 살펴보면 GetPackageEvent의 event와 Emitter&amp;lt;PackageState&amp;gt;의 emit을 파라미터로 가지는 것을 확인할 수 있습니다.event는 말 그대로 이 함수를 호출한 이벤트를 의미하고 emit은 하위 위젯에서 상위 위젯으로 이벤트를 전달하기 위한 것입니다.간단하게 표현하면 현재 해당 BLoC을 사용중인 위젯에서 받는 state를 변경하는 부분이라고 하면 되겠네요.일단 무지성 try-catch로 에러를 잡아주도록 하겠습니다. 그리고 에러가 발생할 경우 emit을 통해서 Error state로 변경하고 message prop에 에러 값을 넣어줍니다.그게 아닐 경우, emit을 통해서 Loading state로 변경해줍니다.로딩 상태에 들어간 이후에는 저희가 아까 만들었던 packageRepository 오브젝트에서 패키지 리스트를 불러옵니다. 이 때, event.pages (GetPackageEvent의 멤버)를 통해서 페이지 값을 가져와서 넣어줍니다.resp에서 받은 JSON값을 packages 변수에 넣어주고 Loaded state로 변경을 해줍니다. 이 때, package prop에 지금 정보를 갖고 있는 package 변수를 넣어줍니다. void _onAppendPackageEvent( AppendPackageEvent event, Emitter&amp;lt;PackageState&amp;gt; emit) async { try { if (state is Loaded) { final parsedState = (state as Loaded); final resp = await packageRepository.getPackages(event.pages); final packages = resp .map&amp;lt;Package&amp;gt;( (e) =&amp;gt; Package.fromJson(e), ) .toList(); final prevPackages = [ ...parsedState.packages, ]; final newPackages = [ ...prevPackages, ...packages, ]; emit(Loaded(packages: newPackages)); } }_onAppendPackageEvent도 거의 동일합니다. 하지만, 이는 state가 Loaded state 일 때만 동작을 하고, Loaded state에서 가져온 값과 현재 값을 이어서 다시 넣어주는 방식으로 진행합니다.UImain.dartimport &#39;package:bloc_practice/bloc/package_bloc.dart&#39;;import &#39;package:bloc_practice/domain/constant/score_value.dart&#39;;import &#39;package:bloc_practice/repository/package_repository.dart&#39;;import &#39;package:flutter/material.dart&#39;;import &#39;package:flutter_bloc/flutter_bloc.dart&#39;;import &#39;domain/colors/colors.dart&#39;;import &#39;model/package.dart&#39;;void main() { runApp(const MyApp());}class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: &#39;BLoC Practice&#39;, theme: ThemeData( primarySwatch: Colors.blue, ), home: BlocProvider( create: (context) =&amp;gt; PackageBloc(packageRepository: PackageRepository()), child: const MyHomePage(), ), ); }}class MyHomePage extends StatefulWidget { const MyHomePage({Key? key}) : super(key: key); @override State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt; _MyHomePageState();}class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { int pages = 1; @override void initState() { super.initState(); BlocProvider.of&amp;lt;PackageBloc&amp;gt;(context).add(GetPackageEvent(pages: pages)); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(&#39;BLoC Practice&#39;), ), body: BlocBuilder&amp;lt;PackageBloc, PackageState&amp;gt;( builder: (context, state) { if (state is Empty) { return Container(); } else if (state is Loading) { return const Center( child: CircularProgressIndicator(), ); } else if (state is Loaded) { final packages = state.packages; return ListView.separated( itemCount: packages.length, itemBuilder: (context, index) { final package = packages[index]; return _ListTile(package: package); }, separatorBuilder: (context, index) =&amp;gt; const Divider(), ); } else if (state is Error) { return Text(state.message); } return Container(); }, ), floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), onPressed: () { context.read&amp;lt;PackageBloc&amp;gt;().add( AppendPackageEvent(pages: ++pages), ); }, ), ); }}class _ListTile extends StatelessWidget { final Package package; const _ListTile({required this.package}); @override Widget build(BuildContext context) { return Padding( padding: const EdgeInsets.all(8.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &amp;lt;Widget&amp;gt;[ Text( package.name, style: const TextStyle( fontSize: 18, color: ViewColors.primaryColor, fontWeight: FontWeight.bold, ), ), const SizedBox(height: 8.0), Text( package.description, style: const TextStyle( color: ViewColors.primaryTextColor, ), ), const SizedBox(height: 8.0), Row( mainAxisAlignment: MainAxisAlignment.center, children: &amp;lt;Widget&amp;gt;[ Column( children: &amp;lt;Widget&amp;gt;[ Text( package.likes.toString(), style: const TextStyle( color: ViewColors.primaryColor, fontWeight: FontWeight.bold, ), ), const Text( ScoreValue.likes, style: TextStyle(fontSize: 10), ), ], ), const SizedBox(width: 16), Column( children: &amp;lt;Widget&amp;gt;[ Text( package.pubPoints.toString(), style: const TextStyle( color: ViewColors.primaryColor, fontWeight: FontWeight.bold, ), ), const Text( ScoreValue.pubPoints, style: TextStyle(fontSize: 10), ), ], ), const SizedBox(width: 16), Column( children: &amp;lt;Widget&amp;gt;[ Text( package.popularity.toString() + &#39;%&#39;, style: const TextStyle( color: ViewColors.primaryColor, fontWeight: FontWeight.bold, ), ), const Text( ScoreValue.popularity, style: TextStyle(fontSize: 10), ), ], ), ], ), const SizedBox(height: 16.0), Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &amp;lt;Widget&amp;gt;[ Text( package.version, style: const TextStyle( color: ViewColors.primaryColor, fontSize: 10, ), ), package.nullSafety ? Container( child: const Text( &quot;Null safety&quot;, style: TextStyle( color: ViewColors.primaryColor, fontSize: 10, ), ), margin: const EdgeInsets.only(left: 8), padding: const EdgeInsets.symmetric( horizontal: 8, vertical: 6), decoration: BoxDecoration( borderRadius: const BorderRadius.all( Radius.circular(20), ), border: Border.all(color: ViewColors.primaryColor), ), ) : Container(), ], ), ], ), ); }}_ListTile 클래스는 리스트 타일을 의미하는 클래스이므로 대충 보고 넘겨도 됩니다.저희가 중요하게 봐야할 알짜배기들만 모아서 아래에 설명하겠습니다.class MyApp extends StatelessWidget { // More codes here.. @override Widget build(BuildContext context) { return MaterialApp( // More codes here.. home: BlocProvider( create: (context) =&amp;gt; PackageBloc(packageRepository: PackageRepository()), child: const MyHomePage(), ), // More codes here..}BLoC을 사용하기 위해서는 BLoC을 사용하고자 하는 위젯 상단에 BlocProvider를 넣어줘야 합니다.여기서는 사용할 bloc 클래스를 create에 정의해줘야하는데 저희는 PackageBloc으로 하겠습니다.이 후, 홈 위젯이 생성이 되면 event를 호출해줍니다. @override void initState() { super.initState(); BlocProvider.of&amp;lt;PackageBloc&amp;gt;(context).add(GetPackageEvent(pages: pages)); }초기 page의 값을 1로 두고 해당 페이지 값을 prop 값으로 넘겨 GetPackageEvent를 호출해주었습니다.이를 처리하기 위해서는 BlocProvider.of&amp;lt;&amp;gt;().add(Event)를 호출해야 합니다.또한, FAB를 누를 때 마다 AppendPackageEvent를 호출해주기 위해서 이 값을 넣어준 것입니다. floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), onPressed: () { context.read&amp;lt;PackageBloc&amp;gt;().add( AppendPackageEvent(pages: ++pages), ); }, ),이제 BLoC State에 따라서 값을 출력해주기만 하면 됩니다. body: BlocBuilder&amp;lt;PackageBloc, PackageState&amp;gt;( builder: (context, state) { if (state is Empty) { return Container(); } else if (state is Loading) { return const Center( child: CircularProgressIndicator(), ); } else if (state is Loaded) { final packages = state.packages; return ListView.separated( itemCount: packages.length, itemBuilder: (context, index) { final package = packages[index]; return _ListTile(package: package); }, separatorBuilder: (context, index) =&amp;gt; const Divider(), ); } else if (state is Error) { return Text(state.message); } return Container(); }, ),BLoCBuilder를 통해서 state에 따라 값을 출력하려고 합니다.저희는 아래와 같이 생성할게요. state가 Empty일 경우, 빈 공간 생성 state가 Loading일 경우, 로딩하는 동글동글한 프로그래스 인디케이터 생성 state가 Loaded일 경우, Loaded state의 멤버인 packages값을 불러와서 그 값을 토대로 리스트를 생성 state가 Error일 경우 텍스트에 오류 출력 이게 끝입니다. 생각보다 간단하고 어렵지 않죠?Conclusion완성된 앱의 모습진짜 끝지금까지 BLoC 패턴을 알아보았습니다. BLoC은 비즈니스 로직과 UI를 나누는 부분에 있어서 좋은 점이 있지만, 이러한 로직마다 최소한 3개의 클래스를 만들어야 하니까 클래스의 개수가 방대하게 늘어날 수 밖에 없는 단점이 있습니다.고로 다음에는 BLoC의 보다 간단한 Provider를 준비해오겠습니다!" }, { "title": "[Flutter] Equatable, 이렇게 좋은데도 안 써?", "url": "/posts/what-is-equatable/", "categories": "Develop, Flutter", "tags": "Flutter, Equatable", "date": "2022-02-07 21:12:00 +0900", "snippet": "Before Start.Equatable 패키지를 어쩌다 알게 되었나BLoC 아키텍처 패턴을 공부하기 위해서 다른 개발자 분들의 코드를 살펴보던 중, 많은 분들이 state, event 클래스를 생성할 때 Equatable 클래스를 상속받는 것을 보고 처음에는 아는 것 없이 무지성으로 저도 Equatable을 상속받아서 생성 했었습니다.하지만 아무것도 모르면서 쓰는 것 보다는 알고 사용하는 것이 훨씬 좋겠죠? 결국 궁금증에 못 이겨 Equatable에 대해서 알아본 결과 생각한 것 보다 좋은 패키지라는 것을 알 수 있었습니다.그래서 Equatable이 뭔데?결론부터 알려드리자면 두 개의 인스턴스가 같은 인스턴스인지를 쉽게 판단해주는 패키지입니다.Getting Started.Equatable을 사용하지 않을 시클래스 선언class Shoes { final int productId; final String name; final String brand; final int size; Shoes({ required this.productId, required this.name, required this.brand, required this.size, });}위와 같은 Shoes 클래스를 생성하고 아래 두 개의 인스턴스를 생성했습니다.인스턴스 생성final myJordan1 = Shoes(productId: 10000, name: &quot;Jordan 1&quot;, brand: &quot;Nike&quot;, size: 280);final yourJordan1 = Shoes(productId: 10000, name: &quot;Jordan 1&quot;, brand: &quot;Nike&quot;, size: 280);위와 같이 myJordan1과 yourJordan1을 생성했습니다.내꺼 == 니꺼??위 두 인스턴스는 모두 같은 값을 가지고 있으니까 myJordan1 == yourJordan1을 하면 true가 나올까요? 아닙니다. 두 값은 다른 메모리에 저장되어 있는 독립된 객체들이기 때문에 두 값을 비교하면 false가 나오게 됩니다.두 값이 같은지 확인하는 방법그러면 두 인스턴스가 같은지 확인을 하려면 어떻게 해야할까요? 다른 언어들처럼 operator를 override하여 두 인스턴스를 비교할 수 있습니다.class Shoes { final int productId; final String name; final String brand; final int size; Shoes({ required this.productId, required this.name, required this.brand, required this.size, }); @override bool operator ==(Object other) =&amp;gt; other is Shoes &amp;amp;&amp;amp; other.productId == productId &amp;amp;&amp;amp; other.name == name &amp;amp;&amp;amp; other.brand == brand &amp;amp;&amp;amp; other.size == size; @override int get hashCode =&amp;gt; productId;}operator ==에서 productId와 name, brand, size가 같을 경우 true를 리턴하게 했습니다. 이를 통해서 myJordan1 == yourJordan1이 true를 리턴할 수 있겠네요!hashCode 함수는 뭐야?근데 operator 이외에도 override된 것이 하나 더 보이네요. 아마 직접 operator를 넣으면 파란색 밑줄이 생기면서 아래와 같이 hashCode도 정의하라고 합니다.Override `hashCode` if overriding `==`.Implement `hashCode`.hashCode는 Map이나 Set과 같이 중복되는 값이 들어가지 못할 때 그 중복되는 것을 의미하는 Key값을 정의할 수 있습니다.이렇게 하면 어렵지 않게 두 인스턴스를 비교할 수 있습니다! 그러면 도대체 Equatable은 왜 쓰는 걸까요?? 이보다 더 쉽게 비교할 수 있기 때문입니다! 😄Equatable을 사용하여 해결Equatable을 사용하기 위해서는 Equatable을 우선 추가 해야겠죠? 터미널에 아래 커멘드를 입력하여 설치를 할 수 있습니다!$ flutter pub add equatable클래스 생성위에 있던 Shoes 클래스에서 operator와 hashCode를 삭제한 후 equatable을 상속 받겠습니다.또한 상속을 받으면 함수 하나를 override하라고 하면서 빨간 줄이 뜨기 때문에 해당 함수도 overriding 해줄게요!class Shoes extends Equatable { final int productId; final String name; final String brand; final int size; Shoes({ required this.productId, required this.name, required this.brand, required this.size, }); @override // TODO: implement props List&amp;lt;Object?&amp;gt; get props =&amp;gt; throw UnimplementedError();}비교할 값들을 props에 추가저는 productId, name, brand, size가 전부 같아야지만 동일한 인스턴스라고 판단할거기 때문에 이 값들을 props에 추가했습니다! :)class Shoes extends Equatable { final int productId; final String name; final String brand; final int size; Shoes({ required this.productId, required this.name, required this.brand, required this.size, }); @override List&amp;lt;Object?&amp;gt; get props =&amp;gt; [productId, name, brand, size];}이러면 끝입니다! myJordan1 == yourJordan1을 확인해보면 true인 것을 확인할 수 있었습니다.ConclusionReferences [equatable Dart Package (pub.dev)](https://pub.dev/packages/equatable) felangel/equatable: A Dart package that helps to implement value based equality without needing to explicitly override == and hashCode. (github.com)" }, { "title": "[Flutter] 위젯의 크기 / 위치 값을 가져오는 법", "url": "/posts/flutter-get-size-of-widget/", "categories": "Develop, Flutter", "tags": "Flutter", "date": "2022-01-18 23:49:00 +0900", "snippet": "Before Start.위젯의 크기 및 위치를 얻는 방법들 LayoutBuilder Global Key 및 RenderBox를 활용 MeasuredSize이번 포스트에서는 Global Key를 통해서 구하는 방법을 알아보겠습니다.Getting Started.기본 코드class MyHomePage extends StatefulWidget { const MyHomePage({Key? key}) : super(key: key); @override State&amp;lt;MyHomePage&amp;gt; createState() =&amp;gt; _MyHomePageState();}class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(&#39;위젯 사이즈 구하기&#39;), ), body: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: &amp;lt;Widget&amp;gt;[ Text(&quot;컨테이너 정보: &quot;), Center( child: Container( color: Colors.blue, padding: const EdgeInsets.all(20), child: const Text(&quot;컨테이너입니다.&quot;), ), ), ], ), ); }}플러터 프로젝트를 새로 생성한 뒤에 크기 및 위치를 구하려고 하는 컨테이너와 사이즈 값을 출력할 텍스트를 배치 하였습니다.여기서 이제 Global Key와 RenderBox를 활용하여 파란색 컨테이너의 크기와 위치를 구해보겠습니다.크기 / 위치를 얻으려는 컨테이너에 Global Key 넣기class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { final GlobalKey _containerkey = GlobalKey(); // (... 생략 ...)Global Key를 위와 같이 생성합니다. 키를 생성한 뒤에는 해당 키를 위젯에 부여해야겠죠?저는 파란색 컨테이너의 정보를 얻고 싶은 것이므로 해당 위젯에 값을 넣어주겠습니다.class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { // (... 생략 ...) @override Widget build(BuildContext context) { // (... 생략 ...) child: Container( key: _containerKey, color: Colors.blue, padding: const EdgeInsets.all(20), child: const Text(&quot;컨테이너입니다.&quot;), ), // (... 생략 ...)key: _containerKey로 키 값을 컨테이너에 넣었습니다. 이제 해당 키 값을 통해서 RenderBox를 생성하여 크기와 위치를 구해보겠습니다!크기를 구하는 함수 만들기class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { // (... 생략 ...) Size? _getSize() { if (_containerKey.currentContext != null) { final RenderBox renderBox = _containerKey.currentContext!.findRenderObject() as RenderBox; Size size = renderBox.size; return size; } } // (... 생략 ...)Global Key를 통해서 생성한 파란색 컨테이너의 RenderBox를 구하고 위젯의 크기를 리턴합니다. 크기는 RenderBox의 size를 통해서 구할 수 있습니다.위치를 구하는 함수 만들기class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { // (... 생략 ...) Offset? _getOffset() { if (_containerKey.currentContext != null) { final RenderBox renderBox = _containerKey.currentContext!.findRenderObject() as RenderBox; Offset offset = renderBox.localToGlobal(Offset.zero); return offset; } } // (... 생략 ...)위치를 구하는 방법은 크기를 구하는 방법이랑 거의 유사합니다. 위치는 RenderBox의 localToGlobal() 메소드를 통해서 구할 수 있습니다.두 값을 한 번에 구하는 함수를 생성해도 되지만 이번 포스트에서는 함수를 따로 제작하여 진행하려고 합니다!함수 호출당연한 이야기지만 위젯의 크기나 위치의 값을 받아오기 위해서는 위젯이 먼저 화면에 존재해야 합니다. 따라서 위젯이 존재하지 않는데 크기나 위치를 구하면 해당 값은 null으로 반환됩니다.하지만 build는 적합하지 않고 initState나 didChangeDependencies는 화면에 위젯을 그리기 전이니 어디서 호출을 해야할까요..정말 간단하게 WidgetsBinding의 addPostFrameCallback()을 통해서 해결 가능합니다. 해당 콜백 함수는 위젯이 바인딩 된 후에 호출하는 함수로 해당 함수 내에서 위젯의 크기 및 위치를 받는 함수를 호출하면 되겠네요!class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { // (... 생략 ...) Size? size; Offset? offset; @override void initState() { super.initState(); WidgetsBinding.instance!.addPostFrameCallback((_) { setState(() { size = _getSize(); offset = _getOffset(); }); }); } // (... 생략 ...)크기 값을 저장할 size 변수와 위치 값을 저장할 offset 변수를 생성한 후 initState()에서 WidgetsBinding.instance!.addPostFrameCallback((_) {...});를 통해 위젯이 바인딩 된 후에 size와 offset을 받아오도록 하였습니다.값을 잘 받아왔는지 확인Text(&quot;컨테이너 정보\\nwidth:${size?.width}\\nheight:${size?.height}\\ndx:${offset?.dx}\\ndy:${offset?.dy}&quot;),파란색 컨테이너의 값을 잘 받아왔는지 확인하기 위해서 텍스트에다가 사이즈 값과 위치 값을 출력 시켜보겠습니다.값이 제대로 잘 출력이 되네요!Conclusion전체 코드코드 전체를 보여드리면서 마무리 하겠습니다.class MyHomePage extends StatefulWidget { const MyHomePage({Key? key}) : super(key: key); @override State&amp;lt;MyHomePage&amp;gt; createState() =&amp;gt; _MyHomePageState();}class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { final GlobalKey _containerKey = GlobalKey(); Size? size; Offset? offset; @override void initState() { super.initState(); WidgetsBinding.instance!.addPostFrameCallback((_) { setState(() { size = _getSize(); offset = _getOffset(); }); }); } Size? _getSize() { if (_containerKey.currentContext != null) { final RenderBox renderBox = _containerKey.currentContext!.findRenderObject() as RenderBox; Size size = renderBox.size; return size; } } Offset? _getOffset() { if (_containerKey.currentContext != null) { final RenderBox renderBox = _containerKey.currentContext!.findRenderObject() as RenderBox; Offset offset = renderBox.localToGlobal(Offset.zero); return offset; } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(&#39;위젯 사이즈 구하기&#39;), ), body: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: &amp;lt;Widget&amp;gt;[ Text( &quot;컨테이너 정보\\nwidth:${size?.width}\\nheight:${size?.height}\\ndx:${offset?.dx}\\ndy:${offset?.dy}&quot;), Center( child: Container( key: _containerKey, color: Colors.blue, padding: const EdgeInsets.all(20), child: const Text(&quot;컨테이너입니다.&quot;), ), ), ], ), ); }}ReferencesHow to get height of a widget해당 Stack Overflow 글을 참조하였습니다." }, { "title": "[Go] golang을 처음 접할 때 알아야할 알짜배기", "url": "/posts/beginning-golang/", "categories": "Develop, Go", "tags": "Go", "date": "2022-01-07 17:48:00 +0900", "snippet": "Before start.노마드코더에서 쉽고 빠른 Go 시작하기를 학습하며 새로 배운 사실들을 공부하면서 적은 글 입니다.ReferencesGolang Study에 공부를 하며 작성한 예제 프로그램과 각 챕터마다 README를 적어놓았습니다.Getting Started.formatting packageimport &quot;fmt&quot;Print somethingimport &quot;fmt&quot;fmt.Println(&quot;Hello world!&quot;)Private / PublicPublic - 변수 혹은 함수 명을 대문자로 시작할 경우Private - 변수 혹은 함수 명을 소문자로 시작할 경우Constant / Variableconst 상수var변수// 둘은 동일// :=은 새로 만들 때만 사용var name string = &quot;hello&quot;name := &quot;hello&quot; // 함수 내부에서만 사용 가능FunctionGeneral파라미터 및 리턴 값은 타입을 지정해야 함.func multiply(a int, b int) int { return a * b}orfunc multiply(a, b int) int { return a * b}리턴 값은 두 개 이상일 수도 있다!!func lenAndUpper(name string) (int, string) { return len(name), strings.ToUpper(name)}func main() { // _ means ignore totalLength, upperName := lenAndUpper(&quot;Hong Gil Dong&quot;) second, _ := lenAndUpper(&quot;Hong Gil Dong&quot;)}...을 통해서 여러 개의 값을 파라미터로 가져올 수 있다.func repeatMe(words ...string) { fmt.Println(words)}func main() { repeatMe(&quot;Kim&quot;, &quot;Lee&quot;, &quot;Han&quot;, &quot;Hong&quot;, &quot;Kyu&quot;)}똑같이 ...을 통해서 여러 개의 값을 파라미터로 넣을 수 있다.hi := []string{&quot;hello&quot;, &quot;hi&quot;}hello := []string{}hello = append(hello, hi...) // ...을 이용하여 여러개를 넣을 수 있음.Naked return아래와 같이 리턴 값을 미리 정해둘 수 있다.func lenAndUpper(name string) (length int, uppercase string) { length = len(name) uppercase = strings.ToUpper(name) return}func main() { // _ means ignore totalLength, upperName := lenAndUpper(&quot;Hong Gil Dong&quot;) fmt.Println(totalLength, upperName)}deferReally cool featuredefer로 입력된 부분은 함수가 끝난 다음에 호출이 됨.func lenAndUpper(name string) (length int, uppercase string) { defer fmt.Println(&quot;I&#39;m done&quot;) length = len(name) uppercase = strings.ToUpper(name) return}LoopGo에는 for 이외에 loop를 도는 방법이 없음.For each 느낌// Index onlyfor number := range numbers { fmt.Println(number)}// Index and numberfor index, number := range numbers { fmt.Println(index, number)}전통적인 for 느낌for i := 0; i &amp;lt; len(numbers); i++ { fmt.Println(numbers[i])}if else기본 모습if age &amp;lt; 18 { return false} else { return true}go에서는 if문 내에서도 변수를 선언할 수 있다.// Variable expressionkoreanAge := age + 2if koreanAge &amp;lt; 18 { return false}// Is equal as belowif koreanAge := age + 2; koreanAge &amp;lt; 18 { return false}Switchswitch age {case 16: return falsecase 18: return true}go에서는 switch안에 expression이 들어가도 됨.switch {case age &amp;lt; 16: return falsecase age == 18: return truecase age &amp;gt; 50: return false}또한 if else와 동일하게 Variable expression이 가능하다.switch koreanAge:= age + 2; koreanAge { // Put case here..}Pointer기본적으로 C와 동일func pointerExample() { a := 5 b := &amp;amp;a fmt.Println(&amp;amp;a) // Address of a fmt.Println(b) // Same as &amp;amp;a fmt.Println(*b) // point value of b}Array정적 할당 배열func arrayExample() { // [length]type{init values} names := [5]string{&quot;hello&quot;, &quot;world&quot;, &quot;:)&quot;} names[3] = &quot;sup&quot; names[4] = &quot;have a nice day!&quot;}Slices동적으로 크기를 변경하는 배열을 생성할 수도 있다.func slicesExample() { // 정적 배열을 생성할 때에서 배열의 크기 부분만 없애면 됨. names := []string{&quot;hello&quot;, &quot;world&quot;, &quot;:)&quot;} // 값 추가는 append 함수를 사용해서 추가하면 됨. names = append(names, &quot;sup&quot;)}Mapvariable := map[string]string{&quot;Hello&quot;: &quot;World&quot;, &quot;Nice&quot;: &quot;day!&quot;}// map[key]value{init values}다른 언어들과 같이 map을 for loop에 돌릴 수 있음.for key, value := range variable { fmt.Println(key, &quot;is&quot;, value)}value, ok := variable[&quot;Hello&quot;]위와 같이 값을 잘 받아왔는지 ok를 통해서 받아올 수 있음.structC나 C++처럼 struct를 사용하여 구조체를 생성할 수 있음.{ &quot;name&quot;: &quot;kim&quot;, &quot;age&quot;: 18}위와 같이 value 부분에 dynamically하게 object가 들어가게 하는 방법은 struct를 사용하는 것.구조체에는 메소드를 생성할 수 있음.구조체 선언만드는 방식은 다른 언어들과 비슷하나 ,를 추가해서는 안됨.type person struct { name string age int favFood []string}구조체 생성생성하는 것도 다른 언어랑 비슷하나 map과 같이 key값을 명시하여 출력하는 것을 선호.favFood := []string{&quot;sushi&quot;, &quot;kimbap&quot;, &quot;ramen&quot;, &quot;rice&quot;, &quot;eggplant&quot;}// 명확하지 않음.kim := person{&quot;Hong Gil Dong&quot;, 26, favFood}// key 값을 명시해줌.kim := person{name:&quot;Hong Gil Dong&quot;, age:26, favFood: favFood}// 전체 출력fmt.Println(kim)// 일부 출력fmt.Println(kim.name)After basic course.go에는 클래스가 없다.Comments구조체 export 시상단에 Comments를 생성해아하며 첫 문자는 구조체 명을 적어야 함.// Account Structtype Account struct {}go.modgo 디렉토리 내부에서 코딩을 하는 것이 아니라 로컬 디렉토리에서 모듈을 새로 만드니까 import를 할 수 없는 오류가 생기면 go.mod를 통해서 해결해야 함. 프로젝트 Root Directory에서 go.mod 생성 $ go mod init main go mod를 초기화 하여 현재 디렉토리를 main으로 한다. 생성하고자 하는 Module Directory 내에서 go.mod 생성 $ cd banking$ go mod init banking go mod를 생성한 뒤에 다시 Root Directory로 이동한다. 프로젝트 Root Directory에서 Module Directory 변경 replace main.com/banking =&amp;gt; ./banking main.com/banking을 import 할 경우 현재 directory 내에 있는 banking directory를 자동으로 import 하게 함. Module Linking $ go mod tidy 해당 명령어를 입력하면 자동으로 연결이 된다. Constructorgo의 구조체는 constructor가 없으므로 함수로 직접 빼서 만들어야 한다.// NewAccount creates a new account.func NewAccount(owner string) *account { account := account{owner: owner, balance: 0} return &amp;amp;account}Methodgo에서 메소드를 생성하기 위해서는 func와 메소드 이름 사이에 구조체를 적어주면 된다.func (a Account) Deposit(amount int) { // (a Account) means receiver. // 보통은 receiver의 명을 struct 명의 첫 글자를 소문자로 한다.}...account // Account type object.account.Deposit() // 이렇게 method가 된다.값을 변경하기 위해서는 receiver가 pointer야 한다.func (a *Account) Deposit(amount int) { // a를 포인터로 받아와야한다. // 이유는 C나 C++와 동일.}String()String() 메소드는 해당 구조체를 print할 때 출력하는 값을 의미한다. python의 **str**`와 동일.func (a Account) String() string { return fmt.Sprint(a.Owner(), &quot;&#39;s account.\\nHas: &quot;, a.Balance())}Error handling// Withdraw x amount from your account.func (a *Account) Withdraw(amount int) error { if a.balance &amp;lt; amount { return errors.New(&quot;Can&#39;t withdraw from account&quot;) } a.balance -= amount // nil means no error return nil}errors.Error() 혹은 errors.New()로 에러를 생성하면 된다. 에러가 없으면 nil을 리턴해주는 것으로 처리.err := account.Withdraw(20)if err != nil { log.Fatalln(err)}log.Fatalln은 프로그램을 출력 후 종료시켜준다.var errNoMoney = errors.New(&quot;Can&#39;t withdraw from account&quot;)에러 변수를 만들 때는 변수 이름을 err로 시작해야한다.typestruct에서 만들었을 때도 봤겠지만 type은 뒤에 있는 것의 alias를 입력하게 해주는 것이다.C나 C++에서의 typedef와 비슷.type Dictionary map[string]stringhttpGETget 메소드를 실행하기 위해서는 http를 이용해야 한다.resp, err := http.Get(url)이렇게 얻은 response의 값에서 status code는 아래 방식으로 얻을 수 있다.resp.StatusCodemakemap과 같은 것은 초기화를 해야하고 초기화를 하지 않았을 시에 오류가 발생한다.// OKresults := map[string]string{}var results = make(map[string]string)// Panicresults := map[string]stringvar results map[string]string위에서 Panic부분은 값을 추가하려고 하면 정상적으로 진행되지 않는다.ConcurrencyGoroutines단순히 함수를 호출할 때 앞에다가 go를 붙여주면 됨.func main() { go hello(&quot;kim&quot;) hello(&quot;lee&quot;)}func hello(name string) { fmt.Println(&quot;Hello,&quot; name)}하지만 main function이 종료가 되면 병렬처리가 되고 있던 작업들도 전부 종료됨.Channelspipe를 통해서 값을 전달하는 것을 channel이라고 한다.c := make(chan bool) // chan typego myFunc(..., c)위와 같은 방식으로 channel을 만들고 goroutine 함수에 인자값으로 넣어주면 된다.그 후에는 함수 안에서 인자값을 처리해주면 된다.func myFunc(..., c chan bool) { // Your codes here.. c &amp;lt;- true}// chan 대신 chan&amp;lt;-으로 적어서 send only로 만들 수 있음.func myFunc(..., c chan&amp;lt;- bool) { // Your codes here.. fmt.Prinlnt(&amp;lt;-c) // error!}값을 넣어줄 때에는 &amp;lt;- 화살표를 통해서 넣어주면 된다.c := make(chan bool)...result := &amp;lt;-c// 바로 출력할 경우 fmt.Println(&amp;lt;-c)동일하게 channel의 값을 변수로 넣어줄 때도 &amp;lt;-를 활용하면 된다.이 떄는 호출을 한 함수(예제의 경우 main)에서 값을 가져올 때까지 기다린다.C의 pthread_join과 Dart의 await와 비슷하게 다음 코드로 넘어가지 않는 것 같음.c := make(chan bool)people := [2]string{&quot;kim&quot;, &quot;lee&quot;}for _, person := range people { go isAwesome(person, c)}fmt.Println(&amp;lt;-c)fmt.Println(&amp;lt;-c)위와 같이 channel을 두 번 호출했으면 값을 두 번 받을 수 있음. 만약에 두 번 호출하고 세 번 이상 값을 받으려고 하면 deadlock에 걸림.Go queryjQuery와 비슷한데 Go버전의 라이브러리임.$ go get github.com/PuerkitoBio/goquery페이지에서 읽기res, err := http.Get(/* Your URL Here.. */)doc, err := goquery.NewDocumentFromReader(res.Body)doc.Find(&quot;Class name of website&quot;)해당 클래스의 값을 갖는 오브젝트를 생성하는 방법이다.doc.Find(&quot;Class name of website&quot;).Each(func(i int, s *goquery.Selection) { // Each values.. // i =&amp;gt; index // s =&amp;gt; each values})얻은 오브젝트에서 값을 하나씩 돌아가면서 loop를 도는 방법이다.Find가 아니라 Attribute를 통해서도 값을 얻을 수 있다.val, exists = doc.Attr(&quot;Attributes&quot;)StringString Conversionstrconv를 사용하여 값을 String으로 변경할 수 있음.strconv.Itoa(5000)strings.TrimSpaceTrimSpace를 이용해서 string 앞뒤에 있는 빈 공간을 제거할 수 있음.strings.TrimSpace(&quot;Hello\\n\\nWor ld&quot;)strings.Fields텍스트를 텍스트의 배열로 나눠줌.// Return value is string[]strings.Fields(strings.TrimSpace(&quot;Hello\\n\\nWor ld&quot;))strings.Join텍스트 배열을 하나로 합치면서 sep을 넣어줌.strings.Join(strings.Fields(strings.TrimSpace(&quot;Hello\\n\\nWor ld&quot;)), &quot; &quot;)TrimSpace + Fields + Joinstrings.Join(strings.Fields(strings.TrimSpace(&quot; Hello\\n\\nWor ld &quot;)), &quot; &quot;)를 실행할 경우 아래와 같이 변경 됨. TrimSpace &quot;Hello\\n\\nWor ld&quot; Fields &quot;Hello&quot;, &quot;Wor&quot;, &quot;ld&quot; Join &quot;Hello Wor ld&quot; CSVcreate filefile, err := os.Create()create New CSV / Flush itw := csv.NewWriter(file)defer w.Flush()CSV에 쓰기header := []string{&quot;id&quot;, &quot;title&quot;, &quot;location&quot;, &quot;company&quot;, &quot;salary&quot;, &quot;summary&quot;, &quot;upload&quot;}wErr := w.Write(header)ECHO를 통한 웹 통신install echo$ go get github.com/labstack/echo프로젝트에 echo 추가main.goimport &quot;github.com/labstack.echo&quot;$ go mod tidyecho 오브젝트 생성 및 GET 처리func handleHome(c echo.Context) error { return .String(http.StatusOK, /* Put value here*/ )}...e := echo.New()e.GET(&quot;/&quot;, handleHome)echo 서버 시작e.Logger.Fatal(e.Start(&quot;:PORT_NO&quot;))" }, { "title": "[Flutter] 패키지 생성 후 pub.dev에 publish하기", "url": "/posts/publish-to-pub-dev/", "categories": "Develop, Flutter", "tags": "Flutter", "date": "2022-01-05 21:00:00 +0900", "snippet": "Before Start.Dart Packages vs Flutter Packages.Figure 1 Dart Packages Dart로만 짜여진 일반적인 패키지를 의미합니다. 각 Platform마다 따로 처리를 할 필요가 없으면 다트 패키지로 만드는 것 같습니다. Plugin Packages 다트 패키지와 다르게 각 Platfrom마다 다르게 처리를 해 줄 필요가 있을 경우에는 플러그인 패키지로 생성하는 것 같습니다. 추가적으로 플러그인 패키지로 패키지를 생성할 경우 example 폴더가 기본적으로 생성되나 다트 패키지로 패키지를 생성할 경우에는 example 폴더가 기본적으로 생기지 않습니다.이번 포스트에서는 Dart 코드를 통해서 퍼블리싱을 진행하겠습니다.ReferencesFlutter Heatmap Calendar위 링크를 참조하면서 진행하시면 더욱 쉽게 진행하실 수 있습니다!시작 전 주의사항패키지명이 이미 pub.dev에 올라와 있을 경우 올릴 수 없고 파일 명과 패키지 명을 하나 하나 전부 수정한 후 다시 검사를 해야하니 사전에 pub.dev에서 패키지명을 먼저 꼭!! 검색해본 후에 프로젝트를 생성해주시길 바랍니다.Getting Started.패키지 만들기다트 패키지를 생성하기 위해서는 --template=package flag를 추가하여 flutter create를 호출해야 합니다.$ flutter create --template=package YOUR_PACKAGE_NAME만약에 다트 패키지가 아니라 플러그인 패키지를 생성하기 위해서는 --org, --platforms, -a 혹은 -i 옵션 또한 추가해야 합니다.$ flutter create --org com.example --template=plugin --platforms=android,ios -a kotlin YOUR_PACKAGE_NAME--org 옵션을 사용하여 organization을 명시할 수 있습니다.--platforms 옵션을 사용하여 적용할 플랫폼을 명시할 수 있으며, 적용 가능한 플랫폼은 android, ios, web, linux, macos, windows가 있습니다.-a 옵션은 적용할 플랫폼 중 안드로이드가 있을 경우 사용할 언어를 의미하며 kotlin, java중에서 하나를 선택할 수 있습니다.-i 옵션은 적용할 플랫폼 중 iOS가 있을 경우 사용할 언어를 의미하며 objc, swift중 하나를 선택할 수 있습니다.이번 포스트에서는 다트 패키지를 통해서 패키지를 개발하였습니다.$ flutter create --template=package flutter_heatmap_calendarFigure 2성공적으로 생성이 완료된 경우 Figure 2와 같이 출력됩니다.example 폴더 생성하기다트 패키지로 프로젝트를 생성했기 때문에 폴더 내에 예제를 보여줄 example폴더가 없으므로 아래 명령어를 통해 example 폴더 또한 생성합니다.$ cd flutter_heatmap_calendar$ flutter create example여기까지 준비하셨다면 본격적으로 패키지 개발을 시작할 수 있겠네요!Set Project.Directory 구조Figure 3위의 순서를 따라오셨으면 Figure 3와 같은 디렉토리 구조를 가지게 됩니다.example에 패키지 추가Figure 4exmaple/pubspec.yaml에 자신이 생성한 패키지를 입력해줍니다.패키지 개발하기/lib 폴더에 들어가보면 프로젝트명과 동일한 dart 파일이 하나가 있습니다.깃허브를 둘러보면서 다른 개발자 분들이 어떻게 개발을 하는지 확인을 해보니 해당 파일은 export용으로만 사용하고 실질적인 개발은 /lib/src 디렉토리를 생성하여 내부에서 개발을 진행합니다.Figure 5저 또한 동일하게 Figure 5같이 src 폴더를 추가로 생성해서 내부에서 개발을 했으며 프로젝트명과 동일한 dart 파일은 export용으로 사용하였습니다.Figure 6이런 식으로 말이죠!pubspec.yaml 변경개발을 완료 했으면 이제 pubspec.yaml을 수정해야 합니다.name: flutter_heatmap_calendardescription: A new Flutter package project.version: 0.0.1homepage:기존에는 1 ~ 4번 라인에 위와 같이 적혀있을 것 입니다. 여기서 version은 1.0.0으로, homepage는 자신의 깃허브 프로젝트 url을 입력해주세요.name: flutter_heatmap_calendardescription: Flutter heatmap calendar inspired by github contribution chart which includes traditional mode / calendar mode.version: 1.0.0homepage: https://github.com/devappmin/flutter_heatmap_calendar저는 다음과 같이 적었습니다!README, CHANGELOG 변경README와 CHANGELOG 또한 자신의 프로젝트에 맞게 변경을 해주시면 됩니다.README는 깃허브 뿐만이 아니라 pub.dev에서도 가장 첫 화면에 등장합니다.Figure 7CHANGELOG는 pub.dev에서 changelog 탭을 통해서 확인할 수 있는 변경사항을 넣어두는 부분입니다.Figure 8라이센스 추가 자신의 프로젝트 깃허브에 들어간 뒤 LICENSE를 클릭합니다. Figure 9 연필 모양 아이콘을 클릭합니다. Figure 10 Choose a license template를 클릭하여 자신이 원하는 라이센스를 클릭해줍니다. Publish it.–dry-run을 통한 오류 발견pub.dev에 퍼블리싱을 하기 전에 아래 명령어를 통해서 현재 개발하고 있는 패키지에 오류가 있는지 확인할 수 있습니다.$ flutter pub publish --dry-run만약에 Package has 0 warnings. The server may enforce additional checks.라고 뜨는 경우에는 다음 step으로 넘어가도 됩니다.pub.dev에 퍼블리싱 하기.--dry-run을 무사히 통과하셨다면 해당 옵션을 빼고 퍼블리싱을 하시면 됩니다.$ flutter pub publish중간에 최초 1회 pub.dev 계정으로 로그인하라고 뜨는데 그 때 로그인을 하시면 pub.dev에 등록이 됩니다.pub.dev에서 확인하기퍼블리싱이 완료된 후에는 1시간 이내로 pub points와 사용 가능한 플랫폼, Null safety 여부를 자동으로 올려줍니다!Flutter Heatmap Calendar저 또한 제대로 잘 올라간 것을 확인할 수 있었습니다!" } ]
