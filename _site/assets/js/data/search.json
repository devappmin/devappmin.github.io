[
  
  {
    "title": "[Flutter] 위젯의 크기 / 위치 값을 가져오는 법",
    "url": "/posts/flutter-get-size-of-widget/",
    "categories": "Mobile, Flutter",
    "tags": "Flutter",
    "date": "2022-01-18 23:49:00 +0900",
    





    "snippet": "Before Start.위젯의 크기 및 위치를 얻는 방법들  LayoutBuilder  Global Key 및 RenderBox를 활용  MeasuredSize이번 포스트에서는 Global Key를 통해서 구하는 방법을 알아보겠습니다.Getting Started.기본 코드class MyHomePage extends StatefulWidget {  const MyHomePage({Key? key}) : super(key: key);  @override  State&amp;lt;MyHomePage&amp;gt; createState() =&amp;gt; _MyHomePageState();}class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: const Text(&#39;위젯 사이즈 구하기&#39;),      ),      body: Column(        mainAxisAlignment: MainAxisAlignment.center,        crossAxisAlignment: CrossAxisAlignment.center,        children: &amp;lt;Widget&amp;gt;[          Text(&quot;컨테이너 정보: &quot;),          Center(            child: Container(              color: Colors.blue,              padding: const EdgeInsets.all(20),              child: const Text(&quot;컨테이너입니다.&quot;),            ),          ),        ],      ),    );  }}플러터 프로젝트를 새로 생성한 뒤에 크기 및 위치를 구하려고 하는 컨테이너와 사이즈 값을 출력할 텍스트를 배치 하였습니다.여기서 이제 Global Key와 RenderBox를 활용하여 파란색 컨테이너의 크기와 위치를 구해보겠습니다.크기 / 위치를 얻으려는 컨테이너에 Global Key 넣기class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {  final GlobalKey _containerkey = GlobalKey();  // (... 생략 ...)Global Key를 위와 같이 생성합니다. 키를 생성한 뒤에는 해당 키를 위젯에 부여해야겠죠?저는 파란색 컨테이너의 정보를 얻고 싶은 것이므로 해당 위젯에 값을 넣어주겠습니다.class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {  // (... 생략 ...)  @override  Widget build(BuildContext context) {          // (... 생략 ...)          child: Container(            key: _containerKey,            color: Colors.blue,            padding: const EdgeInsets.all(20),            child: const Text(&quot;컨테이너입니다.&quot;),          ),          // (... 생략 ...)key: _containerKey로 키 값을 컨테이너에 넣었습니다. 이제 해당 키 값을 통해서 RenderBox를 생성하여 크기와 위치를 구해보겠습니다!크기를 구하는 함수 만들기class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {  // (... 생략 ...)  Size? _getSize() {    if (_containerKey.currentContext != null) {      final RenderBox renderBox =          _containerKey.currentContext!.findRenderObject() as RenderBox;      Size size = renderBox.size;      return size;    }  }  // (... 생략 ...)Global Key를 통해서 생성한 파란색 컨테이너의 RenderBox를 구하고 위젯의 크기를 리턴합니다. 크기는 RenderBox의 size를 통해서 구할 수 있습니다.위치를 구하는 함수 만들기class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {  // (... 생략 ...)  Offset? _getOffset() {    if (_containerKey.currentContext != null) {      final RenderBox renderBox =          _containerKey.currentContext!.findRenderObject() as RenderBox;      Offset offset = renderBox.localToGlobal(Offset.zero);      return offset;    }  }  // (... 생략 ...)위치를 구하는 방법은 크기를 구하는 방법이랑 거의 유사합니다. 위치는 RenderBox의 localToGlobal() 메소드를 통해서 구할 수 있습니다.두 값을 한 번에 구하는 함수를 생성해도 되지만 이번 포스트에서는 함수를 따로 제작하여 진행하려고 합니다!함수 호출당연한 이야기지만 위젯의 크기나 위치의 값을 받아오기 위해서는 위젯이 먼저 화면에 존재해야 합니다. 따라서 위젯이 존재하지 않는데 크기나 위치를 구하면 해당 값은 null으로 반환됩니다.하지만 build는 적합하지 않고 initState나 didChangeDependencies는 화면에 위젯을 그리기 전이니 어디서 호출을 해야할까요..정말 간단하게 WidgetsBinding의 addPostFrameCallback()을 통해서 해결 가능합니다. 해당 콜백 함수는 위젯이 바인딩 된 후에 호출하는 함수로 해당 함수 내에서 위젯의 크기 및 위치를 받는 함수를 호출하면 되겠네요!class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {  // (... 생략 ...)  Size? size;  Offset? offset;  @override  void initState() {    super.initState();    WidgetsBinding.instance!.addPostFrameCallback((_) {      setState(() {        size = _getSize();        offset = _getOffset();      });    });  }  // (... 생략 ...)크기 값을 저장할 size 변수와 위치 값을 저장할 offset 변수를 생성한 후 initState()에서 WidgetsBinding.instance!.addPostFrameCallback((_) {...});를 통해 위젯이 바인딩 된 후에 size와 offset을 받아오도록 하였습니다.값을 잘 받아왔는지 확인Text(&quot;컨테이너 정보\\nwidth:${size?.width}\\nheight:${size?.height}\\ndx:${offset?.dx}\\ndy:${offset?.dy}&quot;),파란색 컨테이너의 값을 잘 받아왔는지 확인하기 위해서 텍스트에다가 사이즈 값과 위치 값을 출력 시켜보겠습니다.값이 제대로 잘 출력이 되네요!Conclusion전체 코드코드 전체를 보여드리면서 마무리 하겠습니다.class MyHomePage extends StatefulWidget {  const MyHomePage({Key? key}) : super(key: key);  @override  State&amp;lt;MyHomePage&amp;gt; createState() =&amp;gt; _MyHomePageState();}class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {  final GlobalKey _containerKey = GlobalKey();  Size? size;  Offset? offset;  @override  void initState() {    super.initState();    WidgetsBinding.instance!.addPostFrameCallback((_) {      setState(() {        size = _getSize();        offset = _getOffset();      });    });  }  Size? _getSize() {    if (_containerKey.currentContext != null) {      final RenderBox renderBox =          _containerKey.currentContext!.findRenderObject() as RenderBox;      Size size = renderBox.size;      return size;    }  }  Offset? _getOffset() {    if (_containerKey.currentContext != null) {      final RenderBox renderBox =          _containerKey.currentContext!.findRenderObject() as RenderBox;      Offset offset = renderBox.localToGlobal(Offset.zero);      return offset;    }  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: const Text(&#39;위젯 사이즈 구하기&#39;),      ),      body: Column(        mainAxisAlignment: MainAxisAlignment.center,        crossAxisAlignment: CrossAxisAlignment.center,        children: &amp;lt;Widget&amp;gt;[          Text(              &quot;컨테이너 정보\\nwidth:${size?.width}\\nheight:${size?.height}\\ndx:${offset?.dx}\\ndy:${offset?.dy}&quot;),          Center(            child: Container(              key: _containerKey,              color: Colors.blue,              padding: const EdgeInsets.all(20),              child: const Text(&quot;컨테이너입니다.&quot;),            ),          ),        ],      ),    );  }}ReferencesHow to get height of a widget해당 Stack Overflow 글을 참조하였습니다."
  },
  
  {
    "title": "[Go] golang을 처음 접할 때 알아야할 알짜배기",
    "url": "/posts/beginning-golang/",
    "categories": "Language, Go",
    "tags": "Go",
    "date": "2022-01-07 17:48:00 +0900",
    





    "snippet": "Before start.노마드코더에서 쉽고 빠른 Go 시작하기를 학습하며 새로 배운 사실들을 공부하면서 적은 글 입니다.ReferencesGolang Study에 공부를 하며 작성한 예제 프로그램과 각 챕터마다 README를 적어놓았습니다.Getting Started.formatting packageimport &quot;fmt&quot;Print somethingimport &quot;fmt&quot;fmt.Println(&quot;Hello world!&quot;)Private / PublicPublic - 변수 혹은 함수 명을 대문자로 시작할 경우Private - 변수 혹은 함수 명을 소문자로 시작할 경우Constant / Variableconst 상수var변수// 둘은 동일// :=은 새로 만들 때만 사용var name string = &quot;hello&quot;name := &quot;hello&quot; // 함수 내부에서만 사용 가능FunctionGeneral파라미터 및 리턴 값은 타입을 지정해야 함.func multiply(a int, b int) int {    return a * b}orfunc multiply(a, b int) int {    return a * b}리턴 값은 두 개 이상일 수도 있다!!func lenAndUpper(name string) (int, string) {	return len(name), strings.ToUpper(name)}func main() {    // _ means ignore    totalLength, upperName := lenAndUpper(&quot;Hong Gil Dong&quot;)    second, _ := lenAndUpper(&quot;Hong Gil Dong&quot;)}...을 통해서 여러 개의 값을 파라미터로 가져올 수 있다.func repeatMe(words ...string) {	fmt.Println(words)}func main() {	repeatMe(&quot;Kim&quot;, &quot;Lee&quot;, &quot;Han&quot;, &quot;Hong&quot;, &quot;Kyu&quot;)}똑같이 ...을 통해서 여러 개의 값을 파라미터로 넣을 수 있다.hi := []string{&quot;hello&quot;, &quot;hi&quot;}hello := []string{}hello = append(hello, hi...) // ...을 이용하여 여러개를 넣을 수 있음.Naked return아래와 같이 리턴 값을 미리 정해둘 수 있다.func lenAndUpper(name string) (length int, uppercase string) {	length = len(name)	uppercase = strings.ToUpper(name)	return}func main() {	// _ means ignore	totalLength, upperName := lenAndUpper(&quot;Hong Gil Dong&quot;)	fmt.Println(totalLength, upperName)}deferReally cool featuredefer로 입력된 부분은 함수가 끝난 다음에 호출이 됨.func lenAndUpper(name string) (length int, uppercase string) {	defer fmt.Println(&quot;I&#39;m done&quot;)	length = len(name)	uppercase = strings.ToUpper(name)	return}LoopGo에는 for 이외에 loop를 도는 방법이 없음.For each 느낌// Index onlyfor number := range numbers {    fmt.Println(number)}// Index and numberfor index, number := range numbers {    fmt.Println(index, number)}전통적인 for 느낌for i := 0; i &amp;lt; len(numbers); i++ {    fmt.Println(numbers[i])}if else기본 모습if age &amp;lt; 18 {    return false} else {    return true}go에서는 if문 내에서도 변수를 선언할 수 있다.// Variable expressionkoreanAge := age + 2if koreanAge &amp;lt; 18 {    return false}// Is equal as belowif koreanAge := age + 2; koreanAge &amp;lt; 18 {    return false}Switchswitch age {case 16:    return falsecase 18:    return true}go에서는 switch안에 expression이 들어가도 됨.switch {case age &amp;lt; 16:    return falsecase age == 18:    return truecase age &amp;gt; 50:    return false}또한 if else와 동일하게 Variable expression이 가능하다.switch koreanAge:= age + 2; koreanAge {    // Put case here..}Pointer기본적으로 C와 동일func pointerExample() {    a := 5    b := &amp;amp;a    fmt.Println(&amp;amp;a) // Address of a    fmt.Println(b)  // Same as &amp;amp;a    fmt.Println(*b) // point value of b}Array정적 할당 배열func arrayExample() {    // [length]type{init values}    names := [5]string{&quot;hello&quot;, &quot;world&quot;, &quot;:)&quot;}    names[3] = &quot;sup&quot;    names[4] = &quot;have a nice day!&quot;}Slices동적으로 크기를 변경하는 배열을 생성할 수도 있다.func slicesExample() {    // 정적 배열을 생성할 때에서 배열의 크기 부분만 없애면 됨.    names := []string{&quot;hello&quot;, &quot;world&quot;, &quot;:)&quot;}    // 값 추가는 append 함수를 사용해서 추가하면 됨.    names = append(names, &quot;sup&quot;)}Mapvariable := map[string]string{&quot;Hello&quot;: &quot;World&quot;, &quot;Nice&quot;: &quot;day!&quot;}// map[key]value{init values}다른 언어들과 같이 map을 for loop에 돌릴 수 있음.for key, value := range variable {    fmt.Println(key, &quot;is&quot;, value)}value, ok := variable[&quot;Hello&quot;]위와 같이 값을 잘 받아왔는지 ok를 통해서 받아올 수 있음.structC나 C++처럼 struct를 사용하여 구조체를 생성할 수 있음.{  &quot;name&quot;: &quot;kim&quot;,  &quot;age&quot;: 18}위와 같이 value 부분에 dynamically하게 object가 들어가게 하는 방법은 struct를 사용하는 것.구조체에는 메소드를 생성할 수 있음.구조체 선언만드는 방식은 다른 언어들과 비슷하나 ,를 추가해서는 안됨.type person struct {	name string	age int	favFood []string}구조체 생성생성하는 것도 다른 언어랑 비슷하나 map과 같이 key값을 명시하여 출력하는 것을 선호.favFood := []string{&quot;sushi&quot;, &quot;kimbap&quot;, &quot;ramen&quot;, &quot;rice&quot;, &quot;eggplant&quot;}// 명확하지 않음.kim := person{&quot;Hong Gil Dong&quot;, 26, favFood}// key 값을 명시해줌.kim := person{name:&quot;Hong Gil Dong&quot;, age:26, favFood: favFood}// 전체 출력fmt.Println(kim)// 일부 출력fmt.Println(kim.name)After basic course.go에는 클래스가 없다.Comments구조체 export 시상단에 Comments를 생성해아하며 첫 문자는 구조체 명을 적어야 함.// Account Structtype Account struct {}go.modgo 디렉토리 내부에서 코딩을 하는 것이 아니라 로컬 디렉토리에서 모듈을 새로 만드니까 import를 할 수 없는 오류가 생기면 go.mod를 통해서 해결해야 함.      프로젝트 Root Directory에서 go.mod 생성    $ go mod init main        go mod를 초기화 하여 현재 디렉토리를 main으로 한다.        생성하고자 하는 Module Directory 내에서 go.mod 생성    $ cd banking$ go mod init banking        go mod를 생성한 뒤에 다시 Root Directory로 이동한다.        프로젝트 Root Directory에서 Module Directory 변경    replace main.com/banking =&amp;gt; ./banking    main.com/banking을 import 할 경우 현재 directory 내에 있는 banking directory를 자동으로 import 하게 함.        Module Linking    $ go mod tidy        해당 명령어를 입력하면 자동으로 연결이 된다.  Constructorgo의 구조체는 constructor가 없으므로 함수로 직접 빼서 만들어야 한다.// NewAccount creates a new account.func NewAccount(owner string) *account {	account := account{owner: owner, balance: 0}	return &amp;amp;account}Methodgo에서 메소드를 생성하기 위해서는 func와 메소드 이름 사이에 구조체를 적어주면 된다.func (a Account) Deposit(amount int) {    // (a Account) means receiver.    // 보통은 receiver의 명을 struct 명의 첫 글자를 소문자로 한다.}...account // Account type object.account.Deposit() // 이렇게 method가 된다.값을 변경하기 위해서는 receiver가 pointer야 한다.func (a *Account) Deposit(amount int) {    // a를 포인터로 받아와야한다.    // 이유는 C나 C++와 동일.}String()String() 메소드는 해당 구조체를 print할 때 출력하는 값을 의미한다. python의 **str**`와 동일.func (a Account) String() string {    return fmt.Sprint(a.Owner(), &quot;&#39;s account.\\nHas: &quot;, a.Balance())}Error handling// Withdraw x amount from your account.func (a *Account) Withdraw(amount int) error {	if a.balance &amp;lt; amount {		return errors.New(&quot;Can&#39;t withdraw from account&quot;)	}	a.balance -= amount	// nil means no error	return nil}errors.Error() 혹은 errors.New()로 에러를 생성하면 된다. 에러가 없으면 nil을 리턴해주는 것으로 처리.err := account.Withdraw(20)if err != nil {    log.Fatalln(err)}log.Fatalln은 프로그램을 출력 후 종료시켜준다.var errNoMoney = errors.New(&quot;Can&#39;t withdraw from account&quot;)에러 변수를 만들 때는 변수 이름을 err로 시작해야한다.typestruct에서 만들었을 때도 봤겠지만 type은 뒤에 있는 것의 alias를 입력하게 해주는 것이다.C나 C++에서의 typedef와 비슷.type Dictionary map[string]stringhttpGETget 메소드를 실행하기 위해서는 http를 이용해야 한다.resp, err := http.Get(url)이렇게 얻은 response의 값에서 status code는 아래 방식으로 얻을 수 있다.resp.StatusCodemakemap과 같은 것은 초기화를 해야하고 초기화를 하지 않았을 시에 오류가 발생한다.// OKresults := map[string]string{}var results = make(map[string]string)// Panicresults := map[string]stringvar results map[string]string위에서 Panic부분은 값을 추가하려고 하면 정상적으로 진행되지 않는다.ConcurrencyGoroutines단순히 함수를 호출할 때 앞에다가 go를 붙여주면 됨.func main() {    go hello(&quot;kim&quot;)    hello(&quot;lee&quot;)}func hello(name string) {    fmt.Println(&quot;Hello,&quot; name)}하지만 main function이 종료가 되면 병렬처리가 되고 있던 작업들도 전부 종료됨.Channelspipe를 통해서 값을 전달하는 것을 channel이라고 한다.c := make(chan bool) // chan typego myFunc(..., c)위와 같은 방식으로 channel을 만들고 goroutine 함수에 인자값으로 넣어주면 된다.그 후에는 함수 안에서 인자값을 처리해주면 된다.func myFunc(..., c chan bool) {    // Your codes here..    c &amp;lt;- true}// chan 대신 chan&amp;lt;-으로 적어서 send only로 만들 수 있음.func myFunc(..., c chan&amp;lt;- bool) {    // Your codes here..    fmt.Prinlnt(&amp;lt;-c) // error!}값을 넣어줄 때에는 &amp;lt;- 화살표를 통해서 넣어주면 된다.c := make(chan bool)...result := &amp;lt;-c// 바로 출력할 경우 fmt.Println(&amp;lt;-c)동일하게 channel의 값을 변수로 넣어줄 때도 &amp;lt;-를 활용하면 된다.이 떄는 호출을 한 함수(예제의 경우 main)에서 값을 가져올 때까지 기다린다.C의 pthread_join과 Dart의 await와 비슷하게 다음 코드로 넘어가지 않는 것 같음.c := make(chan bool)people := [2]string{&quot;kim&quot;, &quot;lee&quot;}for _, person := range people {    go isAwesome(person, c)}fmt.Println(&amp;lt;-c)fmt.Println(&amp;lt;-c)위와 같이 channel을 두 번 호출했으면 값을 두 번 받을 수 있음. 만약에 두 번 호출하고 세 번 이상 값을 받으려고 하면 deadlock에 걸림.Go queryjQuery와 비슷한데 Go버전의 라이브러리임.$ go get github.com/PuerkitoBio/goquery페이지에서 읽기res, err := http.Get(/* Your URL Here.. */)doc, err := goquery.NewDocumentFromReader(res.Body)doc.Find(&quot;Class name of website&quot;)해당 클래스의 값을 갖는 오브젝트를 생성하는 방법이다.doc.Find(&quot;Class name of website&quot;).Each(func(i int, s *goquery.Selection) {    // Each values..    // i =&amp;gt; index    // s =&amp;gt; each values})얻은 오브젝트에서 값을 하나씩 돌아가면서 loop를 도는 방법이다.Find가 아니라 Attribute를 통해서도 값을 얻을 수 있다.val, exists = doc.Attr(&quot;Attributes&quot;)StringString Conversionstrconv를 사용하여 값을 String으로 변경할 수 있음.strconv.Itoa(5000)strings.TrimSpaceTrimSpace를 이용해서 string 앞뒤에 있는 빈 공간을 제거할 수 있음.strings.TrimSpace(&quot;Hello\\n\\nWor    ld&quot;)strings.Fields텍스트를 텍스트의 배열로 나눠줌.// Return value is string[]strings.Fields(strings.TrimSpace(&quot;Hello\\n\\nWor     ld&quot;))strings.Join텍스트 배열을 하나로 합치면서 sep을 넣어줌.strings.Join(strings.Fields(strings.TrimSpace(&quot;Hello\\n\\nWor     ld&quot;)), &quot; &quot;)TrimSpace + Fields + Joinstrings.Join(strings.Fields(strings.TrimSpace(&quot;   Hello\\n\\nWor     ld   &quot;)), &quot; &quot;)를 실행할 경우 아래와 같이 변경 됨.  TrimSpace    &quot;Hello\\n\\nWor     ld&quot;        Fields    &quot;Hello&quot;, &quot;Wor&quot;, &quot;ld&quot;        Join    &quot;Hello Wor ld&quot;      CSVcreate filefile, err := os.Create()create New CSV / Flush itw := csv.NewWriter(file)defer w.Flush()CSV에 쓰기header := []string{&quot;id&quot;, &quot;title&quot;, &quot;location&quot;, &quot;company&quot;, &quot;salary&quot;, &quot;summary&quot;, &quot;upload&quot;}wErr := w.Write(header)ECHO를 통한 웹 통신install echo$ go get github.com/labstack/echo프로젝트에 echo 추가main.goimport &quot;github.com/labstack.echo&quot;$ go mod tidyecho 오브젝트 생성 및 GET 처리func handleHome(c echo.Context) error {    return .String(http.StatusOK, /* Put value here*/ )}...e := echo.New()e.GET(&quot;/&quot;, handleHome)echo 서버 시작e.Logger.Fatal(e.Start(&quot;:PORT_NO&quot;))"
  },
  
  {
    "title": "[Flutter] 패키지 생성 후 pub.dev에 publish하기",
    "url": "/posts/publish-to-pub-dev/",
    "categories": "Mobile, Flutter",
    "tags": "Flutter",
    "date": "2022-01-05 21:00:00 +0900",
    





    "snippet": "Before Start.Dart Packages vs Flutter Packages.Figure 1      Dart Packages    Dart로만 짜여진 일반적인 패키지를 의미합니다. 각 Platform마다 따로 처리를 할 필요가 없으면 다트 패키지로 만드는 것 같습니다.        Plugin Packages    다트 패키지와 다르게 각 Platfrom마다 다르게 처리를 해 줄 필요가 있을 경우에는 플러그인 패키지로 생성하는 것 같습니다.  추가적으로 플러그인 패키지로 패키지를 생성할 경우 example 폴더가 기본적으로 생성되나 다트 패키지로 패키지를 생성할 경우에는 example 폴더가 기본적으로 생기지 않습니다.이번 포스트에서는 Dart 코드를 통해서 퍼블리싱을 진행하겠습니다.ReferencesFlutter Heatmap Calendar위 링크를 참조하면서 진행하시면 더욱 쉽게 진행하실 수 있습니다!시작 전 주의사항패키지명이 이미 pub.dev에 올라와 있을 경우 올릴 수 없고 파일 명과 패키지 명을 하나 하나 전부 수정한 후 다시 검사를 해야하니 사전에 pub.dev에서 패키지명을 먼저 꼭!! 검색해본 후에 프로젝트를 생성해주시길 바랍니다.Getting Started.패키지 만들기다트 패키지를 생성하기 위해서는 --template=package flag를 추가하여 flutter create를 호출해야 합니다.$ flutter create --template=package YOUR_PACKAGE_NAME만약에 다트 패키지가 아니라 플러그인 패키지를 생성하기 위해서는 --org, --platforms, -a 혹은 -i 옵션 또한 추가해야 합니다.$ flutter create --org com.example --template=plugin --platforms=android,ios -a kotlin YOUR_PACKAGE_NAME--org 옵션을 사용하여 organization을 명시할 수 있습니다.--platforms 옵션을 사용하여 적용할 플랫폼을 명시할 수 있으며, 적용 가능한 플랫폼은 android, ios, web, linux, macos, windows가 있습니다.-a 옵션은 적용할 플랫폼 중 안드로이드가 있을 경우 사용할 언어를 의미하며 kotlin, java중에서 하나를 선택할 수 있습니다.-i 옵션은 적용할 플랫폼 중 iOS가 있을 경우 사용할 언어를 의미하며 objc, swift중 하나를 선택할 수 있습니다.이번 포스트에서는 다트 패키지를 통해서 패키지를 개발하였습니다.$ flutter create --template=package flutter_heatmap_calendarFigure 2성공적으로 생성이 완료된 경우 Figure 2와 같이 출력됩니다.example 폴더 생성하기다트 패키지로 프로젝트를 생성했기 때문에 폴더 내에 예제를 보여줄 example폴더가 없으므로 아래 명령어를 통해 example 폴더 또한 생성합니다.$ cd flutter_heatmap_calendar$ flutter create example여기까지 준비하셨다면 본격적으로 패키지 개발을 시작할 수 있겠네요!Set Project.Directory 구조Figure 3위의 순서를 따라오셨으면 Figure 3와 같은 디렉토리 구조를 가지게 됩니다.example에 패키지 추가Figure 4exmaple/pubspec.yaml에 자신이 생성한 패키지를 입력해줍니다.패키지 개발하기/lib 폴더에 들어가보면 프로젝트명과 동일한 dart 파일이 하나가 있습니다.깃허브를 둘러보면서 다른 개발자 분들이 어떻게 개발을 하는지 확인을 해보니 해당 파일은 export용으로만 사용하고 실질적인 개발은 /lib/src 디렉토리를 생성하여 내부에서 개발을 진행합니다.Figure 5저 또한 동일하게 Figure 5같이 src 폴더를 추가로 생성해서 내부에서 개발을 했으며 프로젝트명과 동일한 dart 파일은 export용으로 사용하였습니다.Figure 6이런 식으로 말이죠!pubspec.yaml 변경개발을 완료 했으면 이제 pubspec.yaml을 수정해야 합니다.name: flutter_heatmap_calendardescription: A new Flutter package project.version: 0.0.1homepage:기존에는 1 ~ 4번 라인에 위와 같이 적혀있을 것 입니다. 여기서 version은 1.0.0으로, homepage는 자신의 깃허브 프로젝트 url을 입력해주세요.name: flutter_heatmap_calendardescription: Flutter heatmap calendar inspired by github contribution chart which includes traditional mode / calendar mode.version: 1.0.0homepage: https://github.com/devappmin/flutter_heatmap_calendar저는 다음과 같이 적었습니다!README, CHANGELOG 변경README와 CHANGELOG 또한 자신의 프로젝트에 맞게 변경을 해주시면 됩니다.README는 깃허브 뿐만이 아니라 pub.dev에서도 가장 첫 화면에 등장합니다.Figure 7CHANGELOG는 pub.dev에서 changelog 탭을 통해서 확인할 수 있는 변경사항을 넣어두는 부분입니다.Figure 8라이센스 추가      자신의 프로젝트 깃허브에 들어간 뒤 LICENSE를 클릭합니다.    Figure 9        연필 모양 아이콘을 클릭합니다.    Figure 10        Choose a license template를 클릭하여 자신이 원하는 라이센스를 클릭해줍니다.  Publish it.–dry-run을 통한 오류 발견pub.dev에 퍼블리싱을 하기 전에 아래 명령어를 통해서 현재 개발하고 있는 패키지에 오류가 있는지 확인할 수 있습니다.$ flutter pub publish --dry-run만약에 Package has 0 warnings. The server may enforce additional checks.라고 뜨는 경우에는 다음 step으로 넘어가도 됩니다.pub.dev에 퍼블리싱 하기.--dry-run을 무사히 통과하셨다면 해당 옵션을 빼고 퍼블리싱을 하시면 됩니다.$ flutter pub publish중간에 최초 1회 pub.dev 계정으로 로그인하라고 뜨는데 그 때 로그인을 하시면 pub.dev에 등록이 됩니다.pub.dev에서 확인하기퍼블리싱이 완료된 후에는 1시간 이내로 pub points와 사용 가능한 플랫폼, Null safety 여부를 자동으로 올려줍니다!Flutter Heatmap Calendar저 또한 제대로 잘 올라간 것을 확인할 수 있었습니다!"
  }
  
]

